\startcomponent luagraph-example

\environment luagraph-environment

\startchapter [title={Example, plotting data}]

\placeinitial
The best way to learn how to use any system is through examples,
hopefully starting simple. As the problem here is to plot data, we first
need to obtain some set of data to be analyzed.

The Desert Knowledge Australia Solar Centre (DKASC) is a solar power
technology demonstration facility for commercialised solar technologies
operating in the arid solar conditions of Alice Springs, Central
Australia, near the geographic center of the Australian continent
(see, \goto{http://dkasolarcentre.com.au/about}
       [url(http://dkasolarcentre.com.au/about)]).
It is a public source of some cool data:
\goto{http://dkasolarcentre.com.au/historical-data}
 [url(http://dkasolarcentre.com.au/historical-data)].
For example, the file \type {101-Site_DKA-WeatherStation.csv.gz}
contains over a million records of weather data (wind speed,
temperature, humidity, radiation, etc.) recorded at five minute
intervals
\startfootnote
Each data point consists of 10~second samples averaged over 5~minutes.
\stopfootnote
over the past ten years. (To download this file, one must
agree to their conditions, and then gets to play \quotation {I'm not a
robot} games.) According to the public \emphasis {terms and conditions},
the following caveat must be displayed:
\startquotation
Desert Knowledge Australia, the Australian Government, the Northern
Territory Government and the project managers, Ekistica do not endorse,
and accept no legal liability whatsoever arising from, or connected to,
the outcomes and conclusions associated with the use of data from the
Desert Knowledge Australia Solar Centre.
\stopquotation

To read this data (after uncompressing the gzipped file), we first load
the module \type {luagraph}. It creates a \METAPOST\ instance named
\type {graph} that we will use from now on.

\startbuffer                                                                                            
\usemodule [luagraph]

\startMPcode {graph}                                                                                    
string f[] ; numeric n[] ;                                                                              
f0 := "dkasolarcentre.com.au/101-Site_DKA-WeatherStation.csv" ;
n0 := lua.mp.CSVDataLoad(f0) ;                                               

draw textext(f0 & ": " & decimal n0 & " records") ;
\stopMPcode                                                                                             
\stopbuffer                                                                                             
                                                                                                        
\typebuffer

producing:

\getbuffer 

Note that it takes a few seconds or more (depending on the speed of your
system) to read this file; note also that your favorite spreadsheet
application would have choked before reaching the end of this file!
Let's see what it contains:

\startbuffer
\startluacode
local list = userdata.list

for f in next,list do
    local lf = list[f]
    local hf = lf.header

    context.bold(f)
    context.starttabulate { "|r|r|r|" }
    context.NC()
      context.bold("record")
      context.NC()
      for c=1,2 do
        context.bold(hf[c])
        context.NC()
      end
    context.NR()
    -- loop over the first couple and last records
    for k, v in pairs { 1, 2, 3, #lf } do
      context.NC()
        context(v~=3 and tostring(v) or "…")
        context.NC()
        for c=1,2 do
          if v~=3 then
            context(lf[v][c])
          else
            -- empty
          end
          context.NC()
        end
      context.NR()
    end
    context.stoptabulate()
end
\stopluacode
\stopbuffer

\getbuffer

The data \quote {lives} in \LUA|-|space, i.e. memory, and is easily
accessible. The above table was produced using the following code:

\typebuffer

so we have seen examples of how to access the data though \METAPOST\ and
through \LUA. The data consists of records and fields, and these can
contain anything: no assumption has been made as to the contents. We see
from above that the first field contains a timestamp in a
standard|-|conforming format. Although it is not stated explicitly on
the website, one can assume that this is in local time for Alice
Springs, Australia (ACST, UTC+9:30 hours). \LUA\ easily allows us to
convert this to more convenient units and, although this could be easily
handled automatically, the macros and functions can remain more general
if we add fields, having made these conversions ourselves. This also
illustrates how one can add fields of derived data, perhaps combinations
or differences, following any desired function or form, as needed.

\startbuffer [luasyncdata]
\startluacode
local sub    = string.sub
local ostime = os.time
local sort   = table.sort
local byseconds = function (a,b) return (a.seconds < b.seconds) end

local list = userdata.list

for f in next,list do
    local lf = list[f]
    if not lf[1].seconds then
        local hf = lf.header
        local monthdayyear = false
        for pass=1,2 do
            for i=1,#lf do
                local lfi  = lf[i]
                local timestamp = lfi[1]
                local t = utilities.parsers.totime(timestamp)
                if monthdayyear then
                    t.month,t.day = t.day,t.month
                elseif t.month > 12 then
                    monthdayyear = true
                    break
                end
                local seconds = ostime(t)
                lfi.seconds = seconds
                lfi.minutes = seconds/60
                lfi.hours   = seconds/3600
                lfi.days    = seconds/3600/24
                lfi.weeks   = seconds/3600/24/7
                lfi.months  = seconds/3600/24/365.25*12
                lfi.years   = seconds/3600/24/365.25
                t.hour,t.min,t.sec = 0,0,0
                lfi.hourofday = (seconds-ostime(t))/3600
                if sub(timestamp,5,16) == "-01-01 00:00" then
                    hf["New Year "..sub(timestamp,1,4)] = i
                end
            end
            if not monthdayyear then break end
        end
        sort(lf,byseconds)
        -- Save modifications to cache file(s)
        local basename = file.nameonly(f)
        local tmafile  = basename .. ".tma"
        local tmcfile  = basename .. ".tmc"
        table.save(tmafile,lf)
        utilities.lua.compile(tmafile,tmcfile)
        file.syncmtimes(f,tmafile)
        file.syncmtimes(f,tmcfile)
    end
end
\stopluacode
\stopbuffer

\typebuffer [luasyncdata]

\getbuffer [luasyncdata]

Of course, \type {months} and \type {years} are approximate units, for
they do not take into account the irregularities of the Gregorian
calendar, but they will be reliable metrics for the evolution of time.

The data is sorted by increasing date (seconds) if it was not so in the
original file.

\startnarrower

The function \type {lua.mp.CSVDataLoad(filename)} also caches the data,
saving it in the form of a \LUA\ table in a file named \type
{filename.tua} as well as a compiled (64~bit binary) version in a file
named \type {filename.tuc}. This compiled file is then efficiently
loaded for subsequent passes or a new typesetting run of the source file.
Although it is not necessary to update these cache files here, we take
advantage and do so as to also economize re|-|processing the data in
future passes or runs.

\stopnarrower

The data can be easily plotted, drawn as a simple graphic. In the
following example: 

\startbuffer
\startMPcode {graph}
startgraph (TextWidth,TextHeight/5)
    gdraw binpath(lua.mp.CSVDataPath(f0,0,3),60/5)
        withpen pencircle scaled .24bp ;
stopgraph ;
\stopMPcode
\stopbuffer

\typebuffer

\startplacefigure [location=force,
    title={Time|-|series of recorded temperature, five|-|minute sampling
    averages binned to one|-|hour averages}]
    \getbuffer
\stopplacefigure

The third field (3) contains the temperature, in Celsius, and the
graphic shows a yearly seasonable periodicity as well as a daily
variation or range. We also see that the data set contains a few
glitches (probably due to system incidents). This is to be expected when
working with any real set of data.

The above graphic, in a style that Edward Tufte has called \quote
{sparklines}, contains a ridiculous amount of information. Indeed, the
rendering of the page can be slow or even beyond the capacity of the
display application, and it can be zoomed to an extreme factor. (A line
width was used here that corresponds to the resolution of a standard
printer.) There are no labels, and no scale is indicated.

The \METAPOST\ commands \type {startgraph(…)} … \type {stopgraph ;} 
delimits a code snippet defining a graph.
\startfootnote
The Hobby \type {graph} macros used
\type {begingraph(…)} … \type {endgraph ;} 
but in keeping more in line with \CONTEXT\ syntax, we use
\type{start}/\type{stop}. This should alert the user that something is
up and to expect that the commands will be slightly different.
\stopfootnote
In the above example, we give
the width and height \type {(TextWidth,TextHeight/5)} to declare a
drawing canvas, here a rectangular region. It is flexible, for given
just a single number, this will declare a square region, and given any
(closed) \type {path}, this path will outline the canvas or graph region.
One can also give a \type {picture}, having decorations, color and
labels (or even an image), defining a drawing canvas. Finally, one can
omit any argument and any previously used canvas will be reemployed.

The command \type {gdraw} is the equivalent of \type {draw} but in the
graph (user coordinates) space. It take the data, a path transferred
from \LUA\ and maps it to the drawing space of the canvas. Without any
specific directives, it will \emphasis {autoscale}, fitting the extents
of the user space to the extents of the canvas or drawing space. More
precisely, the user space bounding box is transformed to coincide with
the canvas bounding box by an affine transformation. Note that
\METAPOST\ solves this autotransformation handily.

The \LUA\ function \type {CSVDataPath()} (in the \type {mp} namespace)
takes the previously|-|loaded data of the filename \type {f0} (a string)
and returns a path where the abscissa is the field \quote {0},
interpreted to be the record index, and the ordinate is the field \quote
{3}, silently skipping any records having an empty field (this file has
some). In order to reduce the density of the data, read in as
five|-|minute averages, the function \type {binpath()} is used to
produce one hour averages (binning twelve five|-|minute data points).

Let's redraw this data, setting and drawing a scale, taking the time (in
years) as the abscissa:

\startbuffer
\startMPcode {graph}
path p ; p := binpath(lua.mp.CSVDataPath(f0,"years",3),12) ;

startgraph () % reuse the previous frame
    setscale ((whatever,-10),(whatever,whatever)) ;
    autogrid.llft() withcolor .5[white,black] ;
    gdraw p withpen pencircle scaled .24bp ;
    label.bot("time (years)", frame)
        shifted (down*LineHeight) ;
    label.lft(btex temperature (°C) etex rotated 90, frame)
        shifted (left*LineHeight) ;
stopgraph ;
\stopMPcode
\stopbuffer

\typebuffer

\startplacefigure [location=force,
    title={Time|-|series of recorded temperature, one|-|hour sampling averages}]
    \getbuffer
\stopplacefigure

The command \type {setscale()} takes two pairs $(x,y)$, or four numbers
$(x_{\mathrm{min}},y_{\mathrm{min}},
  x_{\mathrm{max}},y_{\mathrm{max}})$,
here we only set the ordinate minimum to $-10$, allowing the other
limits to autoscale. The command \type {autogrid} arranges the placement
of a grid with the numbering on the lower|-|left sides of the canvas. It
is drawn at 50\%\ grayscale, halfway between the colors \type {white}
and \type {black}. As black is \type {(0,0,0)} in rgb and white is \type
{(1,1,1)}, this could have been written more compactly as \type
{.5white}. (\METAPOST\ is so much fun!) The labeling, given \type
{frame} as a position, places the typeset text relative to the canvas
frame.

One point of detail to be taken: the \type {setscale()} command \bold
{must} appear before the other commands, notably the \type {autogrid()}
command, for it resets the user (data) space and a number of internal
parameters. This is to allow graphs having multiple scales drawn on the
same canvas (for example, differing left and right ordinate scales).

The data, being a time|-|series, can be labeled by date, rather then by
the decimal number of years:

\startbuffer
\startMPcode {graph}
setcoordinates (date,lin) ;
datescale := (lua.mp.Time(2019,1,1)-
              lua.mp.Time(2009,1,1))/10 ;
dateepoch :=  lua.mp.Time(2010,1,1) ;
p := p shifted (-dateepoch/datescale,0) ;

startgraph ()
    setscale ((whatever,0),(whatever,whatever)) ;
    autogrid.llft(5,1) withcolor .5white ;
    gdraw p withpen pencircle scaled .24bp ;
    draw frame ;
    label.bot("date (years)", frame)
        shifted (down*LineHeight) ;
    label.lft(btex temperature (°C) etex rotated 90, frame)
        shifted (left*LineHeight) ;
stopgraph ;

setcoordinates(lin,whatever) ; % reset from the previous example
\stopMPcode
\stopbuffer

\startplacefigure [location=force,
    title={Historic temperatures, one|-|hour sampling averages}]
    \getbuffer
\stopplacefigure

\typebuffer

Setting the coordinate system to \type {date}, produces these labels,
but this requires setting two parameters: the \type {datescale}, here
the number of seconds in one year (because the data path abscissa is in
units of years) and a \type {dateepoch}, a reference number of seconds
(from the system epoch) that is to be taken as the zero of the data. The
data path \type {p} is \type {shifted} by \type {-dateepoch/datescale}
to place the $x$-coordinate zero at the first of January, 2010
(otherwise, the zero would be the first of January, 1970, the Unix
epoch). Why should this matter? It serves for the placement of
grid|-|lines which would otherwise be slightly off (29/12/09 17:00:00).
This is because the system is looking for rational grid lines and bases
this on a continuous time scale, not the irregularities of a calendar.
\startfootnote
The system \emphasis {could} use a heuristic to automatically adjust the
offset and scale to mark whole days, months and years, and a future version
may include this.
\stopfootnote
The choice of underlying time units, here years, influences the focus of
the grid lines. Choosing days, for example, would still place a grid
line at the origin (01/01/10 00:00:00), but space subsequent ones at
rational locations, for this set of data in steps of 1000\ days, not a
rational step in years!

The formatting of the date label is controlled by the string \type
{Dateform}, by default set to \type {"@d/@m/@y @H:@M:@S"}. Note that
because \METAPOST\ interprets \type {%} and everything that follows it
as a comment, we substitue \type {@} in the format string and interpret
this appropriately.

Another change from the previous example is the marking of minor
grid lines, dividing the major grid lines of the ordinate into five
minor \emphasis {intervals}, which makes sense for the range of this
data. Minor interval grid lines are obtained through an argument \type
{(5,1)} to the \type {autogrid} command, where the first value is for
the $x$-axis and the second for the $y$-axis; specifying a single number
would apply this to all axes so here we explicitly write \type {1} (the
default) for the second axis.

One might ask about time zones, indeed we note that the notion of
\quote {summer} with the maximum of temperatures centered around the New
Year (January) is inverted from what many of us may think, not being
from Down Under. The conversion from date to a linear time, and back,
depends on the system setting for the timezone, but for a round|-|trip
conversion, as here, this does not matter. When it does, one must take
care to set the desired system timezone (in the environment).

Note that the \type {setcoordinates} command can appear inside or
outside (as here) of the graph itself, and remains in effect. The
argument \type {(date,lin)} is synonymous to the shorthand \type
{(datelin)}. The default coordinate system is, of course, \type
{(lin,lin)}, alias \type {(linlin)}, a rectangular basis.

The data file contains not only a time series recording of the
temperature, but also other meteorological measures as the relative
humidity, the wind speed and direction, the solar irradiance, and the
accumulated rainfall. Plotting one of these measures against another
over all seasons will certainly create a dense packet of data, but can
also reveal correlations or patterns. Take the relative humidity plotted
against the temperature in this arid environment.

\startbuffer
\startMPcode {graph}
startgraph (.5TextWidth)
    setscale(-10,0,whatever,whatever) ;
    autogrid.llft(1,5) withcolor .5white ;
    gdraw binpath(lua.mp.CSVDataPath(f0,3,4),12)
        withpen pencircle scaled .24bp ;

    year := lua.mp.CSVDataValue(f0,0,"New Year 2010") ;
    gdraw binpath(lua.mp.CSVDataPath(f0,3,4,false,year,
                                     year+60/5*24*7),12)
        withcolor blue
        withpen pencircle scaled .24bp ;

    draw frame ;
stopgraph ;
%draw boundingbox currentpicture withcolor red ;
label.bot("temperature (°C)", currentpicture) ;
%draw boundingbox currentpicture withcolor green ;
label.lft(btex relative humidity (\%) etex rotated 90,
                              currentpicture) ;
\stopMPcode
\stopbuffer

\typebuffer

\startplacefigure [location=force,
    width=\textwidth,
     list={Correlation relative humidity vs. temperature},
    title={Correlation relative humidity vs. temperature.
           In blue, the first week of January 2010.}]
    \getbuffer
\stopplacefigure

In this example, the lower values of the range are explicitly set,
in abscissa due to one or a few \quote {bad} data points, and in
ordinate bringing the minimum to zero as the measure never quite reaches
this value. Also drawn (in blue) is the trace of measured data for just
the first week of January, 2010.
\startfootnote
The data trace from the first week in January, being Summer in the
Southern Hemisphere, lies towards the upper range in temperatures. The
correlation with the relative humidity decreasing with increasing
temperature illustrates nicely the arid climate of Alice Springs.
\stopfootnote
This illustrates how the \LUA\ function \type {lua.mp.CSVDataPath()} can
be given optional starting (and ending) indices, limiting the returned
path to this range. The function also takes a (boolean) argument, \type
{false} in the example above, that, if true, would return a closed
(cyclic) path, suitable for filling. (This closed path connects the
first and last points via a segment of the abscissa axis.)

The index of the particular data point of the time series starting the
New Year was identified in the \LUA\ code shown much earlier and stored as
an additional field in the data header,
and accessed as record number 0 (remembering that the data itself uses
the \LUA\ convention of starting counting at 1). The \LUA\ function \type
{lua.mp.CSVDataValue()} is used to access individual record and field
values. Note that this illustrates a second method of identifying
particular date values in the data, compared to \type {lua.mp.Time()},
which calculates and returns a value in seconds from the system Epoch
(in the locale timezone). The data, being 5~minute samples, one week
corresponds to \type {60/5*24*7} points.

One could effectively use this method to flag particular dates or data
points in a time series, for example the solar solstices and equinoxes
when considering weather data such as here!

The label placement, drawn outside of the graph as here, takes into
account the grid numbering when \type {currentpicture} is given as the
positioning reference; the centering is with respect to the drawn
picture, not to the frame only, so slightly pulled to the left and to
the bottom (which I find somewhat less aesthetic|=|it actually looks
much better if one uncomments the drawing of the red and green bounding
boxes, providing a new reference for the eye).

Filling a closed path rather then drawing an open path with a pen or
linewidth of finite size will reveal much finer detail, for one must
keep in mind that the graphic consists of vectorial objects that can be
rendered to any desired resolution of zoom level. We show below an
example, using the data contained in the sixth field of the file:

\startbuffer
\startreusableMPgraphic{graph::Irradiance}
p := binpath(lua.mp.CSVDataPath(f0,0,6),12)
     --(n0,0)--(1,0)--cycle ;
startgraph(TextWidth,TextHeight/3)
    draw frame.rt withcolor .5[blue,white] ;
    drawarrow ((0,-LineHeight)--origin) rotated -30
        shifted lrcorner frame
        withcolor red ;
    setscale (0,0,whatever,800) ;
    autogrid.llft(5,1) withcolor .7white ;
    gfill p ;
    string s ; s := lua.mp.CSVDataValue(f0,0,6) ;
    label.lft(textext(substring (21,length s) of s) rotated 90,
              frame)
        shifted (left*2.5EmWidth) ;
stopgraph ;
\stopreusableMPgraphic
\reuseMPgraphic{graph::Irradiance}
\stopbuffer

\typebuffer

\startplacefigure [location=force,
    title={Irradiance}]
    \getbuffer
\stopplacefigure

\startbuffer
\scale[width=\textwidth,height=.33\textheight]
 {\clip[nx=500,ny=500,x=500,y=467.65]
  {\reuseMPgraphic{graph::Irradiance}}}
\stopbuffer

\startplacefigure [location=force,
    title={Zoom 500×}]
    \getbuffer
\stopplacefigure

The zoom (re)uses the same graphical object:

\typebuffer

The tip of the arrowhead can be seen in red, and the right edge of the
frame drawn in light blue shows the drawing line width (which in this
zoom fills almost the entire window). Each black bar is the foot or
pedestal of the daily peak in the recorded irradiance data, and one can
observe the much finer detail, here the noise in the zero of the
nighttime measurement between daily peaks (in what looks solid black in
the un|-|zoomed rendering). One can zoom much further because there are
in fact 144 data points per 12~hour period. Looking quite carefully, one
can notice the gray zero ordinate grid line behind the data.

Of course, this is a ridiculous density of data that challenges whatever
PDF display or print application that one might use. But luatex can
handle it!

\startsubsubject [title=Summary of tokens introduced in this chapter]

\starttyping
\usemodule [luagraph]
autogrid.numberposition(x-minor,y-minor) ;
binpath(path,binsize)
Dateform
gdraw
lua.mp.CSVDataLoad(filename)
lua.mp.CSVDataPath(filename,xfield,yfield,cycle,first,last)
lua.mp.Time(year,month,day,hour,min,sec)
lua.mp.CSVDataValue(filename,record,field)
setcoordinates() ;
setscale((xmin,ymin),(xmax,ymax)) ;
startgraph() … stopgraph ;
\stoptyping

\stopsubsubject

\stopchapter

\stopcomponent
