\startcomponent luagraph-arrays

\environment luagraph-environment

\startchapter [title={\METAPOST\ \quote {arrays} and paths}]

\placeinitial
Most everything in this chapter is an exercise or proof|-|of|-|concept
and does not show any new functionality and may be skipped in learning
to use the \type {luagraph} macros. However, the chapter explores and
describes important concepts of concern for all \METAPOST\ users.

First, let's explore how \METAPOST\ can be made very \bold
{in}efficient. Hans sent the following \quote {teaser} on the \CONTEXT\
mailing list (slightly modified here):

\startbuffer
\testfeatureonce{1}{\startMPcode {doublefun}
    pair array[] ;
    def get_array(expr c)       = array[c]
        enddef ;
    def set_array(expr c, a, b) = get_array(c) := (a,b) ;
        enddef ;
    numeric n ; n := 10000 ;
    for i=0 upto n :
        set_array(i,i,i*i) ;
    endfor ;
\stopMPcode}set one dimensional array: \elapsedtime\ s\crlf
\testfeatureonce{1}{\startMPcode {doublefun}
    pair p_i ;
    for i=0 upto n :
        p_i := get_array(i) ;
    endfor ;
\stopMPcode}get one dimensional array: \elapsedtime\ s\crlf
\testfeatureonce{1}{\startMPcode {doublefun}
    pair array[][][][] ;
    def get_array(expr c) =
        array[c div 1000][c div 100][c div 10][c mod 10]
        enddef ;
    for i=0 upto n :
        set_array(i,i,i*i) ;
    endfor ;
\stopMPcode}set four dimensional array: \elapsedtime\ s\crlf
\testfeatureonce{1}{\startMPcode {doublefun}
    for i=0 upto n :
        p_i := get_array(i) ;
    endfor ;
\stopMPcode}get four dimensional array: \elapsedtime\ s
\stopbuffer

\typebuffer

\startframed [align=flushright]
  \getbuffer
\stopframed

One sees that a long, single|-|dimensional \quote {array} has to step through a
very long hash to find elements, whereas this hash is simplified (and
accelerated) when the \quote {array} is (artificially) broken into four dimensions.
Basically the hashing can be described through the following:


\starttabulate [|l|l|]
\NC 1D \NC \type {array[n]} : \type {array} $\to$ \type {array.0} $\to$
\type {array.1} $\to$ … \type {array.n} \NR
\NR
\NC 4D \NC \type {array[n div 1000][n div 100][n div 10][n mod 10]} : \NR
\NC    \NC \type {array}                                    $\to$ \NR
\NC    \NC \type {array.0}                                  $\to$ \NR
\NC    \NC … \NR
\NC    \NC \type {array[n div 1000]}                        $\to$ \NR
\NC    \NC \type {array[n div 1000].0}                      $\to$ \NR
\NC    \NC … \NR
\NC    \NC \type {array[n div 1000][n div 100]}             $\to$ \NR
\NC    \NC \type {array[n div 1000][n div 100].0}           $\to$ \NR
\NC    \NC … \NR
\NC    \NC \type {array[n div 1000][n div 100][n div 10]}   $\to$ \NR
\NC    \NC \type {array[n div 1000][n div 100][n div 10].0} $\to$ \NR
\NC    \NC … \NR
\NC    \NC \type {array[n div 1000][n div 100][n div 10][n mod 10]} \NR
\stoptabulate

When $n≫1$, here 10000, the trick results in a much shortened hash
lookup chain: four short (<10|-|step) hashes as opposed to one
$n$|-|step hash. In fact, it does not matter what the last step
contains, and it could just as well be \type {[n]} as \type {[n mod
10]}, for all of the work already has been done and this last step will
only contain at most 10 elements, the more significant digits will
necessarily be the same.

The lesson to be retained is an understanding how \METAPOST\ hashes its
pseudo|-|arrays. It is probably important to remind ourselves that this was a
non|-|issue for the original scaled integer model, where pseudo|-|array as well
as path lengths were limited to a maximum of 4096 elements. The extension of
\METAPOST\ to the alternative numeric models, here double|-|precision floating
point, was accompanied by a lifting of this limitation, with the consequences
that we discover here.

A similar effect occurs when looping over the points of a \type {path}:

\startbuffer
\testfeatureonce{1}{\startMPcode {doublefun}
    def JOIN = hide(def JOIN = -- enddef) enddef ;
    path p ; p := for i=0 upto n :
                      JOIN (i,i*i)
                  endfor ;
\stopMPcode}set path: \elapsedtime\ s\crlf
\testfeatureonce{1}{\startMPcode {doublefun}
    for i=0 upto n :
        p_i := point i of p ;
    endfor ;
\stopMPcode}get path: \elapsedtime\ s
\stopbuffer

\typebuffer

\startframed [align=flushright]
\getbuffer
\stopframed

Wow, that is painful, getting points of a path! This demonstrates that the \type
{point i of} path operator is performing a long hash over all of the points of a
path, very inefficiently. We discussed at the 2018 \CONTEXT\ meeting adding a
more efficient path iterator to \METAPOST, as in:

\starttyping
\startMPcode
    path p ;
    for i within p :
        p_i := point i ;
    endfor
\stopMPcode
\stoptyping

where \type {i} is an iterator and \type {point} is an operator returning the
point value (for there are also two control points for each node in a path:
\type {(x,y)..controls (cx,cy) and (dx,dy)..}). Until such an extension is made
to \METAPOST, let's see what can be done using \LUA.

First, let's try using a \LUA\ table to store data pairs:

\startbuffer
\startluacode
userdata.pairs = { }
local pairs = userdata.pairs
local mpquoted = mp.quoted
local mppair = mp.aux.pair
function mp.setPair(c,a,b)
    c = tonumber(c) + 1
    pairs[c] = { a, b }
end
function mp.getPair(c)
    c = tonumber(c) + 1
    local pc = pairs[c]
    if pc then
        mppair(pc)
    else
        mpquoted("(whatever,whatever)")
    end
end
\stopluacode
\testfeatureonce{1}{\startMPcode {doublefun}
    for i=0 upto n :
        lua.mp.setPair(i,i,i*i) ;
    endfor ;
\stopMPcode}set lua: \elapsedtime\ s\crlf
%
\testfeatureonce{1}{\startMPcode {doublefun}
    for i=0 upto n :
        p_i := lua.mp.getPair(i) ;
    endfor ;
\stopMPcode}get lua: \elapsedtime\ s
\stopbuffer

\typebuffer
\startframed [align=flushright]
\getbuffer
\stopframed

So this is hardly an improvement to say the least, indeed slightly
slower than accessing data in a one|-|dimensional pseudo|-|array of
pairs. We see that this is not the right approach towards handling
arrays, but one can do better with paths. Below is new experimental code
(from \type {mlib-lua.lua}):

\starttyping
    local mpnumeric = aux.numeric
    local mppair    = aux.pair
    local mpgetpath = get.path
    local mpsetpath = set.path -- not working yet

    local p = nil
    local n = 0

    local function mf_path_length(name)
        p = mpgetpath(name)
        n = p and #p or 0
        mpnumeric(n)
    end

    local function mf_path_point(i)
        if i > 0 and i <= n then
            local pi = p[i]
            mppair(pi[1],pi[2])
        end
    end

    local function mf_path_left(i)
        if i > 0 and i <= n then
            local pi = p[i]
            mppair(pi[5],pi[6])
        end
    end

    local function mf_path_right(i)
        if i > 0 and i <= n then
            local pn
            if i == 1 then
                pn = p[2] or p[1]
            else
                pn = p[i+1] or p[1]
            end
            mppair(pn[3],pn[4])
        end
    end
\stoptyping

Te functions \type {mp.get.path} (\type {mpgetpath}) reads a \METAPOST\ path into a
lua table and \type {mp.aux.pair} (\type {mppair}) sends a pair \type {(x,y)}
back to \METAPOST (to be parsed by \type {scantokens}).

The following code completes the experiment (from \type {mp-luas.mpiv}):

\starttyping
def inpath suffix p =
    = 1 step 1 until lua.mp.mf_path_length(str p)
enddef ;

vardef pointof primary i = lua.mp.mf_path_point(i) enddef ;
vardef leftof  primary i = lua.mp.mf_path_left (i) enddef ;
vardef rightof primary i = lua.mp.mf_path_right(i) enddef ;

%% Usage:
%    
%    draw for i inpath p:
%        pointof i .. controls (leftof i) and (rightof i) ..
%    endfor cycle ;
%
%% replaces:
%
%    draw for i=0 upto (length p)-1 :
%        point i of p .. controls (postcontrol  i of p) and
%                                 (precontrol i+1 of p) ..
%    endfor cycle ;
\stoptyping

(Note that this is \italic{experimental}, and the names or syntax might
change in the future.)

Compare this new scheme with the previous, conventional \METAPOST\ loop:

\startbuffer
\testfeatureonce{1}{\startMPcode {doublefun}
    for i inpath p :
        p_i := pointof i ;
    endfor ;
\stopMPcode}inpath…pointof i: \elapsedtime\ s\crlf
\testfeatureonce{1}{\startMPcode {doublefun}
    for i=0 upto length p :
        p_i := point i of p ;
    endfor ;
\stopMPcode}point i of path: \elapsedtime\ s
\stopbuffer

\typebuffer
\startframed [align=flushright,framecolor=red]
\getbuffer
\stopframed

This shows an almost 100× speedup and means that one can use \LUA\ in
this fashion to efficiently manipulate paths. We do not quite take this
approach in the \type {luagraph} macros for there is some overhead in
constantly switching context between \METAPOST\ and \LUA. Rather, it is
more efficient to write specific \LUA\ functions to manipulate paths, an
example of which is the \METAPOST\ macro \type {binpath()} which is just
a wrapper calling a function \type {lua.mp.binPath()}.

\stopchapter

\stopcomponent
