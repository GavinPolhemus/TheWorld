%D \module
%D   [       file=mp-luag.mpiv,
%D        version=2019.01.20,
%D          title=\CONTEXT\ \METAPOST\ graphics,
%D       subtitle=graph package rewrite,
%D         author=Alan Braslau,
%D           date=\currentdate,
%D      copyright={PRAGMA ADE \& \CONTEXT\ Development Team}]
%C
%C This module is part of the \CONTEXT\ macro||package and is
%C therefore copyrighted by \PRAGMA. See licen-en.pdf for
%C details.

if known context_luag : endinput ; fi

boolean context_luag ; context_luag := true ;


anchortextexts := 1 ; % enable saving of textext anchors
labeloffset := EmWidth/2 ; % was 3bp, this works better with axis numbering

newinternal datescale ;  datescale  := 1 ; % seconds: 1, 60, 60i*60, 60*60*24, 60*60*24*7, ...
newinternal dateepoch ;  dateepoch  := 0 ; % seconds: offset from os (unix) epoch

newinternal minorpenscale ;          minorpenscale          := 1/4 ; % minor tic mark penscale
newinternal ticmarklength ;          tichmarklength         := 0 ;  % 0 yields a grid
newinternal graphsymbolsize;         graphsymbolsize        := 2EmWidth/3 ;
newinternal graphsymbolhaloscale ;   graphsymbolhaloscale   := 4/3 ;

newscriptindex lgid_set_transform    ; lgid_set_transform    := scriptindex "settransform" ;
newscriptindex lgid_path_transform   ; lgid_path_transform   := scriptindex "transformPath" ;
newscriptindex lgid_pair_transform   ; lgid_pair_transform   := scriptindex "transformPair" ;
newscriptindex lgid_pair_transform_i ; lgid_pair_transform_i := scriptindex "transformPairInverse" ;
newscriptindex lgid_plotsymbol       ; lgid_plotsymbol       := scriptindex "plotsymbol" ;

% Move to mp-tool.mpiv ?
% further improved plain mp macro

vardef lg_center primary p =
    if pair p :
        p
    elseif picture p :
        .5[llcorner p, urcorner p]
    else : % path: center of gravity
        save n, sum ; pair sum ; sum = origin ;
        n = length p if cycle p : -1 fi ;
        if n<1000 :
            for i = 0 upto n :
                sum := sum + point i of p ;
            endfor
        else : % maybe do all in lua...
            for i inpath str p :
                sum := sum + pointof i ;
            endfor
        fi
        sum / (n+1)
    fi
enddef ;

% From John Hobby's graph module.
%
% augment<path name>(loc)        append given coordinates to a polygonal path

% Append coordinates t to polygonal path @#.  The coordinates can be numerics,
% strings, or a single pair.

vardef augment@#(text t) =
  if not path begingroup @# endgroup :
    warning("Cannot augment--not a path") ;
  else :
    def insert_comma = hide(def insert_comma=,enddef) enddef ;
    if known @# :  @# :=@#--  else :  @#=  fi
    (for p=t :
       insert_comma if string p : scantokens fi p
     endfor) ;
  fi
enddef ;


% Modify a path, point by point.
% Of course this is only useful if the argument is nontrivial.
%
% example :
%
%   p1 := modifypath.p0(shifted (.1normaldeviate,.1normaldeviate)) ;

vardef modifypath@#(text t) =
    if path @# :
        def insert_dotdot= hide(def insert_dotdot=..enddef) enddef ;
        (for i inpath @# :
            insert_dotdot          (pointof i) t
            insert_dotdot controls (leftof  i) t
                          and      (rightof i) t
        endfor if cycle @# : insert_dotdot cycle fi)
    fi
enddef ;

save graphsymbol ; picture graphsymbol[] ;

begingroup
pen savedpen ; savedpen := currentpen ;
pickup pencircle scaled .05 ;
interim ahlength  := .5 ;
interim ahvariant := 1 ;

picture graphsymbol.○ ; graphsymbol.○ = graphsymbol0  = image(draw fullcircle) ;
picture graphsymbol.□ ; graphsymbol.□ = graphsymbol1  = image(draw fullsquare) ;
picture graphsymbol.◇ ; graphsymbol.◇ = graphsymbol2  = graphsymbol.□ rotated 45 ;
picture graphsymbol.△ ; graphsymbol.△ = graphsymbol3  = image(draw
                                                              (dir 90--dir 210--
                                                               dir 330--cycle)
                                                                   scaled (2/3)) ;
picture graphsymbol.▽ ; graphsymbol.▽ = graphsymbol4  = graphsymbol.△ rotated 180 ;
picture graphsymbol.◁ ; graphsymbol.◁ = graphsymbol5  = graphsymbol.△ rotated  90 ;
picture graphsymbol.▷ ; graphsymbol.▷ = graphsymbol6  = graphsymbol.△ rotated -90 ;
picture graphsymbol.☆ ; graphsymbol.☆ = graphsymbol7  = image(draw % sin(162)=.31
                                                              (dir  90--.31dir 126--
                                                               dir 162--.31dir 198--
                                                               dir 234--.31dir 270--
                                                               dir 306--.31dir 342--
                                                               dir  18--.31dir  54--
                                                               cycle) scaled (2/3)) ;
picture graphsymbol.● ; graphsymbol.● = graphsymbol10 = image(fill pathpart graphsymbol.○) ;
picture graphsymbol.■ ; graphsymbol.■ = graphsymbol11 = image(fill pathpart graphsymbol.□) ;
picture graphsymbol.◆ ; graphsymbol.◆ = graphsymbol12 = image(fill pathpart graphsymbol.◇) ;
picture graphsymbol.▲ ; graphsymbol.▲ = graphsymbol13 = image(fill pathpart graphsymbol.△) ;
picture graphsymbol.▼ ; graphsymbol.▼ = graphsymbol14 = image(fill pathpart graphsymbol.▽) ;
picture graphsymbol.◀ ; graphsymbol.◀ = graphsymbol15 = image(fill pathpart graphsymbol.◁) ;
picture graphsymbol.▶ ; graphsymbol.▶ = graphsymbol16 = image(fill pathpart graphsymbol.▷) ;
picture graphsymbol.★ ; graphsymbol.★ = graphsymbol17 = image(fill pathpart graphsymbol.☆) ;
picture graphsymbol.↑ ; graphsymbol.↑ = graphsymbol8  = image(drawarrow down--origin) ;
picture graphsymbol.→ ; graphsymbol.→ = graphsymbol9  = image(drawarrow left--origin) ;
picture graphsymbol.↓ ; graphsymbol.↓ = graphsymbol18 = image(drawarrow up--origin) ;
picture graphsymbol.← ; graphsymbol.← = graphsymbol19 = image(drawarrow right--origin) ;

pickup savedpen ;
endgroup ;

string ○ ; ○ := "○" ;
string □ ; □ := "□" ;
string ◇ ; ◇ := "◇" ;
string △ ; △ := "△" ;
string ▽ ; ▽ := "▽" ;
string ◁ ; ◁ := "◁" ;
string ▷ ; ▷ := "▷" ;
string ☆ ; ☆ := "☆" ;
string ● ; ● := "●" ;
string ■ ; ■ := "■" ;
string ◆ ; ◆ := "◆" ;
string ▲ ; ▲ := "▲" ;
string ▼ ; ▼ := "▼" ;
string ◀ ; ◀ := "◀" ;
string ▶ ; ▶ := "▶" ;
string ★ ; ★ := "★" ;
string ↑ ; ↑ := "↑" ;
string → ; → := "→" ;
string ↓ ; ↓ := "↓" ;
string ← ; ← := "←" ;

def isgraphsymbol(expr p) =                                                
    (picture p and ((substring(0,10) of prescriptpart p) = "gr_symbol_"))
enddef ;

vardef graphsymbolpicture@# =
    if known graphsymbol@# :
        image(save pic; picture pic ;
              pic = graphsymbol@# scaled graphsymbolsize ;
              save c ; pair c ;
              for i within pic :
                  addto currentpicture
                  if stroked i :
                      if cycle pathpart i :
                          contour
                          if istextext(i) :
                              pathpart i
                          else :
                              hide(c := lg_center pathpart i)
                              ((pathpart i) shifted -c
                               scaled graphsymbolhaloscale)
                              shifted c
                          fi
                      else :
                          doublepath pathpart i
                          withpen currentpen scaled graphsymbolhaloscale
                      fi
                  elseif filled i :
                      contour
                      hide(c := lg_center pathpart i)
                      ((pathpart i) shifted -c
                       scaled graphsymbolhaloscale)
                      shifted c
                  else : % ?
                      contour boundingbox i
                  fi withcolor background ;
              endfor
              addto currentpicture also pic ;
             )
    else :
        image(draw outlinetext.b(if not string @# : str fi @#)
                     ()
                     (withcolor background withpen pencircle scaled 1/5)
                   scaled (graphsymbolsize/EmWidth) ;
              currentpicture := currentpicture
                  shifted -lg_center currentpicture ;
             )
    fi
enddef ;

% Note: using % within a string works in MP, but will fail when parsed
% in TeX, so we use the substitute @ and handle this at the lua end...

save Dateform ; string Dateform ; Dateform = "@d/@m/@y @H:@M:@S" ; % date&time 

def resetAutoform =
    save Autoform ; string Autoform,Autoform.x,Autoform.y ; Autoform = "@.6g" ;
enddef ;
resetAutoform ;

vardef AFMT@# = if known Autoform@# : Autoform@# else : Autoform fi enddef ;

% Now in mp-luas.mpxl
%vardef textextanchor(expr p) =
%    runscript("mp.textextanchor(prescriptpart p)")
%enddef ;

% global, so that it can be reused repeatedly ...
save gframe ; path gframe ; picture gframe.pic ;

% Do we want these?
%
% let startgroup = begingroup ;
% let stopgroup  = endgroup ;

def startgraph(text t) =
    begingroup % dangling (endgroup is found in stopgraph).
    save savedpicture ; picture savedpicture ; % currentpicture before startgraph()
         savedpicture = currentpicture ;
         currentpicture := nullpicture ;
    save gpicture ; picture gpicture ; % working picture in data coordinates
         gpicture = nullpicture ;
    save gpath ; path gpath ; % last path drawn in data coordinates

    begingroup
        save ww ;
        for i=t :
            if picture i :
                gframe.pic := i ;
                gframe := pathpart i ;
            elseif path i :
                gframe := i ;
                if not cycle gframe :
                    gframe := gframe--cycle ;
                fi
                gframe.pic := nullpicture ;
            elseif pair i :
                gframe := unitsquare xyscaled i ;
                gframe.pic := nullpicture ;
            elseif numeric i :
                if unknown ww :
                    ww = i ;
                else :
                    message (ww,i) ;
                    gframe := unitsquare xyscaled (ww,i) ;
                    gframe.pic := nullpicture ;
                    save ww ;
                fi
            fi
            exitif (unknown ww) and (known gframe) ;
        endfor
        if known ww :
           gframe := unitsquare scaled ww ;
           gframe.pic := nullpicture ;
        fi
        if unknown gframe :
            ww = 10 ;
            message "Unspecified graph size, defaulting to "&decimal ww&" cm" ;
            gframe = unitsquare scaled (ww*cm) ;
            gframe.pic := nullpicture ;
        fi
    endgroup ;

    % we "borrow" gpicture for a moment...
    gpicture := if length gframe.pic > 0 : gframe.pic
                else : image(draw gframe withpen nullpen) fi ;
    pair gframe.ll ; gframe.ll := llcorner gpicture ;
    pair gframe.ul ; gframe.ul := ulcorner gpicture ;
    pair gframe.lr ; gframe.lr := lrcorner gpicture ;
    pair gframe.ur ; gframe.ur := urcorner gpicture ;
    gpicture := nullpicture ;

    pair gframe.c ; gframe.c := gframe.ur - gframe.ll ;
                    gframe.w := abs(gframe.lr - gframe.ll) ;
                    gframe.h := abs(gframe.ul - gframe.ll) ;

    if length gframe.pic > 0 :
        draw gframe.pic ; % used for backgrounds, etc.
    fi
enddef ;

def stopgraph text t =
    flushgpicture ;
    addto savedpicture also currentpicture t ;
    currentpicture := savedpicture ;
    endgroup
enddef ;

% Do we want these?
%
% let begingraph = startgraph ;
% let endgraph   = stopgraph ;


% allow for non-rectangular frames (where boundingbox frame <> frame)
vardef frame@# =
    % todo: withpen nullpen ... saved corners
    save t ; pair t[] ;
    save s ; string s ; s = str @# ;
    t0 = lg_center gframe ;
    if     s="" :
         % nop
    elseif s="top" :
         t1 = gframe intersectiontimes (t0--ulcorner gframe) ;
         t2 = gframe intersectiontimes (t0--urcorner gframe) ;
    elseif s="urt" :
         t1 = gframe intersectiontimes (t0--.5[ulcorner gframe,urcorner gframe]) ;
         t2 = gframe intersectiontimes (t0--.5[urcorner gframe,lrcorner gframe]) ;
    elseif s="rt" :
         t1 = gframe intersectiontimes (t0--urcorner gframe) ;
         t2 = gframe intersectiontimes (t0--lrcorner gframe) ;
    elseif s="lrt" :
         t1 = gframe intersectiontimes (t0--.5[urcorner gframe,lrcorner gframe]) ;
         t2 = gframe intersectiontimes (t0--.5[lrcorner gframe,llcorner gframe]) ;
    elseif s="bot" :
         t1 = gframe intersectiontimes (t0--llcorner gframe) ;
         t2 = gframe intersectiontimes (t0--lrcorner gframe) ;
    elseif s="llft" :
         t1 = gframe intersectiontimes (t0--.5[lrcorner gframe,llcorner gframe]) ;
         t2 = gframe intersectiontimes (t0--.5[llcorner gframe,ulcorner gframe]) ;
    elseif s="lft" :
         t1 = gframe intersectiontimes (t0--llcorner gframe) ;
         t2 = gframe intersectiontimes (t0--ulcorner gframe) ;
    elseif s="ulft" :
         t1 = gframe intersectiontimes (t0--.5[llcorner gframe,ulcorner gframe]) ;
         t2 = gframe intersectiontimes (t0--.5[ulcorner gframe,urcorner gframe]) ;
    fi
    if known t1 :
        t3 = (xpart t1,xpart t2) ;
        if xpart t1 < xpart t2 :
            t4 = (xpart t1,xpart t2 - length gframe) ;
        else :
            t4 = (xpart t1 - length gframe,xpart t2) ;
        fi
        if arclength subpath t3 of gframe <
           arclength subpath t4 of gframe :
            subpath t3
        else : 
            subpath t4
        fi of
    fi
    gframe
enddef ;

% allow other coordinate systems

newinternal string coordinates ; coordinates := "" ;

% % string helpers:
% 
% save Polar ; string Polar ; Polar = "Polar" ; permanent Polar ;
% newinternal polarscale ; polarscale := 1 ; % period for x (angle): 1, 24, 360, ...
% 
% def xylist = "Lin", "Log", "Sqrt", "Date" enddef ;
% % iterate over combinations:
% for i=xylist :
%     % primaries
%     scantokens("save   "&i) ;
%     scantokens("string "&i) ;
%     scantokens(i)  = i ;
% 
%     scantokens("string "&i)[] ;
%     scantokens(i)0 = i ; % a "primary"
% 
%     scantokens("permanent "&i) ;
%     for j=xylist :
%         % pairs
%         scantokens("save   "&i&j) ;
%         scantokens("string "&i&j) ;
%         scantokens(i&j) = i&j ;
% 
%         scantokens("string "&i&j)[] ;
%         scantokens(i&j)1 = i ; % x
%         scantokens(i&j)2 = j ; % y
% 
%         scantokens("permanent "&i&j) ;
%     endfor
% endfor
% 
% % examples of use:
% % setcoordinates("LinLog") ;
% % setcoordinates(LinLog) ;
% % setcoordinates(Lin,Log) ;
% % setcoordinates(Log) ;    % changes only x in a pair
% % setcoordinates("",Log) ; % changes only y in a pair
% % setcoordinates(Polar,360) ;
% 
% % This could probably be better done in lua, maybe...
% 
% % see also setscale
% vardef setcoordinates(text t) =
%     save s; string s[] ;
%     for i=1,2:
%         if known   scantokens(coordinates)[i] :
%             s[i] = scantokens(coordinates)[i] ;
%         fi
%     endfor ;
%     save j ; j = 1 ;
%     for i=t :
%         if string i :
%             if i = "" :
%                 ;
%             elseif  (known  scantokens(i)0) and
%                     (string scantokens(i)0) :
%                 s[j] := i ;
%             elseif  (known  scantokens(i)1) and
%                     (string scantokens(i)1) :
%                 save s ;
%                 coordinates := i ;
%                 exitif true ;
%             elseif i = "Polar" :
%                 save s ;
%                 coordinates := i ;
%             else:
%                 message "what?" ;
%             fi
%         elseif (numeric i) and (coordinates = "Polar") :
%             polarscale := i ;
%         fi
%         j := j+1 ;
%        %exitif j=3 ; % sanity check...
%     endfor
%     if (known s1) and (known s2) :
%         coordinates := s1&s2 ;
%     fi
%     
%     lua.mp.settransform(coordinates, polarscale) ;
% enddef ;

def setcoordinates =
    coordinates := runscript lgid_set_transform (coordinates)
enddef ;

% primarydef a lg_transformed b =
%     if transform b :
%         a transformed b
%     else :
%         if  picture a :
%             begingroup
%             save pic ; picture pic ;
%             save p ; path p ;
%             for i within a :
%                 if stroked i :
%                     p := pathpart i ;
%                     addto pic doublepath (p lg_transformed b)
%                         withproperties i ;
%                 elseif filled i :
%                     p := pathpart i ;
%                     addto pic contour (p lg_transformed b)
%                         withproperties i ;
%                 fi
%             endfor
%             pic
%             endgroup
%         elseif path a :
%             % TODO: must be a suffix for now
%             if not cycle a : subpath (0,length a) of fi
%             for i inpath a:
%                 (b (pointof i)) .. controls
%                 (b (leftof  i)) and
%                 (b (rightof i)) ..
%             endfor cycle
%         else :
%             (b a) 
%         fi
%     fi
% enddef ;

def do_transform =    (length coordinates > 0) enddef ;
def polar_transform = (coordinates = "Polar") enddef ;

vardef transformpath(expr e) =
    if do_transform :
        if pair e :
            runscript lgid_pair_transform
        else :
            runscript lgid_path_transform
        fi
    fi
    e
enddef ;

vardef transformpair(expr a,b) =
    if do_transform :
        runscript lgid_pair_transform
    fi
    (a,b)
enddef ;

vardef transformpair_i(expr a,b) =
    if do_transform :
        runscript lgid_pair_transform_i
    fi
    (a,b)
enddef ;

vardef binpath@# (expr p, binsize) =
    save bins ; bins = round binsize ;
    if bins>1 :
        runscript("mp.binPath(" & decimal binsize & "," & decimal @# &  ")") p
    else :
        p if @# = 0 : scaled 0 fi
    fi
enddef ;

primarydef a witherrorbars b =
    image(if path a :
              save n ; n = if path b : length b else : -1 fi ;
              for i=0 upto length a :
                  clearxy ; z0 = point i of a ;
                  if i<=n :
                      z1 = point i of b ;
                      draw (x0,y0-y1)--(x0,y0+y1)
                          withprescript "gr_symbol_none=true" ;
                      draw (x0-x1,y0)--(x0+x1,y0)
                          withprescript "gr_symbol_none=true" ;
                  fi
                  draw z0 ;
              endfor
          fi)
enddef ;

primarydef a witherrorregion b =
    image(if path a :
              save n ; n = if path b : length b else : -1 fi ;
              for i=0 upto length a :
                  clearxy ; z = point i of a ;
                  if i<=n :
                      fill (fullcircle xyscaled ((point i of b) scaled 2))
                          shifted z ;
                  fi
                  draw z ;
              endfor
          fi)
enddef ;

newinternal errorbarpicture ;     errorbarpicture     := 1 ;
newinternal errorellipsepicture ; errorellipsepicture := -1 ;
newinternal errorvariancepath ;   errorvariancepath   := 0 ;

% simplified from mp-tool.mpiv

%primarydef p insideof q =
%    begingroup
%        save t ; (t, whatever) = (p--lg_center q) intersectiontimes boundingbox q ;
%        t < 0
%    endgroup
%enddef ;

primarydef p boundedby q =
    begingroup
        save pth ; path pth ; pth = p -- lg_center q ;
        save t ; (t, whatever) = pth intersectiontimes boundingbox q ;
        if t<0 :
            point t of pth
        else :
            p
        fi
    endgroup
enddef ;

% We treat these as separate unknowns rather than as pairs

def xmin = gpicture.minimum.x enddef ;
def ymin = gpicture.minimum.y enddef ;
def xmax = gpicture.maximum.x enddef ;
def ymax = gpicture.maximum.y enddef ;

vardef find_number@# =
    gpicture.number@# = gpicture.tmax@# - gpicture.tmin@# ;
    if gpicture.number@# < 0 : gpicture.number@# := -gpicture.number@# ; fi
    gpicture.power@# = 0 ;
    if gpicture.number@#>10 :
        forever :
            gpicture.number@# := gpicture.number@#/10 ;
            gpicture.power@#  := gpicture.power@# + 1 ;
            exitif gpicture.number@# <= 10 ;
        endfor
    elseif gpicture.number@#<1 :
        forever :
            gpicture.number@# := 10gpicture.number@# ;
            gpicture.power@#  :=   gpicture.power@# - 1 ;
            exitif gpicture.number@# >= 1 ;
        endfor
    fi
    gpicture.number@# := round gpicture.number@# ;
    gpicture.factor@#  =   10**gpicture.power@# ;
    if ((gpicture.tmin@# = gpicture.minimum@#) and
        (gpicture.tmax@# = gpicture.maximum@#)) : % linear transformation
        if gpicture.number@#<4 :
            gpicture.number@# := 2gpicture.number@# ;
            gpicture.factor@# := gpicture.factor@#/2 ;
        fi
    fi
enddef ;

vardef gridandnumbers@# (expr Txy) =
    save xlabel ; boolean xlabel ; xlabel = (str @# = "x") ;
    save isdate ; boolean isdate ;
    isdate = xlabel and (substring (0,4) of coordinates = "Date") ;
    if isdate : save strdate ; string strdate ; fi
    save l ; l = if xlabel: ypart else: xpart fi gpicture.laboff ;
    save al ; % used for tic marks

    if (gpicture.laboff = origin) or (l <> 0) or (known gpicture.minor@#) :
        save m,t,pp,tt,tta ; path pp ; picture tt ; pair tta ;
        t = gpicture.factor@# * floor (gpicture.tmin@#/gpicture.factor@#) ;
        m = if known gpicture.minor@# : gpicture.minor@# else : 1 fi ;
        if m>1 :
            clearxy ; z = lua.mp.minorpair() ;
            if @# <> m :
                m := @# ;
            fi
        fi
        for i=0 upto gpicture.number@#+1 :
            message (if xlabel: "tx" else: "ty" fi & " = " & decimal t) ;
            clearxy ; save d ;
            if polar_transform :
                if xlabel :
                    x = t ;
                    d = gpicture.factor.x ;
                    pp := (t,gpicture.tmin.y) --
                          (t,gpicture.tmax.y) ;
                    pp := transformpath(pp) ;
                else:
                    y = t ;
                    d = gpicture.factor.y ;
                    if t=0 :
                        pp := (0,0) ; %transformpair(0,0) ;
                    else :
                        dx := gpicture.tmax.x - gpicture.tmin.x ;
                        def insert_dotdot = hide(def insert_dotdot = .. enddef) enddef ;
                        pp := for k=0 upto 100 :
                                  insert_dotdot (gpicture.tmin.x+dx*k/100,t)
                              endfor ;
                        pp := transformpath(pp) ;
                    fi
                fi
            else :
                if xlabel :
                    z           = transformpair_i(t,                  gpicture.tmin.y) ;
                   (d,whatever) = transformpair_i(t+gpicture.factor.x,gpicture.tmin.y) ;
                    d := d - x ;
                    pp := (t,gpicture.tmin.y)--(t,gpicture.tmax.y) ;
                else:
                    z           = transformpair_i(gpicture.tmin.x,                  t) ;
                   (whatever,d) = transformpair_i(gpicture.tmin.x,t+gpicture.factor.y) ;
                    d := d - y ;
                    pp := (gpicture.tmin.x,t)--(gpicture.tmax.x,t) ;
                fi
            fi
            if m<>0 : d := d/m ; fi
            if t >= gpicture.tmin@# :
                if l <> 0 :
                    if isdate :
                        strdate := lua.mp.Date(Dateform,round (x*datescale+dateepoch)) ;
                    fi
                    tt  := if polar_transform :
                               if xlabel :
                                   if l<0 : thefmttext    (AFMT.x,x,point 1 of pp)
                                   else :   thefmttext    (AFMT.x,x,point 0 of pp) fi
                               else :
                                   if l<0 : thefmttext    (AFMT.y,y,point infinity of pp)
                                   else :   thefmttext    (AFMT.y,y,point 0 of pp) fi
                               fi
                           else :
                               if xlabel :
                                   if l<0 : if isdate :
                                                   thetextext.bot(strdate, point 0 of pp)
                                            else : thefmttext.bot(AFMT.x,x,point 0 of pp) fi
                                   else :   if isdate :
                                                   thetextext.top(strdate, point 1 of pp)
                                            else : thefmttext.top(AFMT.x,x,point 1 of pp) fi
                                   fi
                               else :
                                   if l<0 : thefmttext.lft(AFMT.y,y,point 0 of pp)
                                   else :   thefmttext.rt (AFMT.y,y,point 1 of pp) fi
                               fi
                           fi ;
                    tta := textextanchor(tt) ;
                    tt  := tt shifted -tta ;
                    tta := tta transformed Txy ;
                    pp  := pp  transformed Txy ;
                    tt  := if polar_transform :
                               thetextext.autoalign
                               if xlabel :
                                   (if tta=origin: 0 else: angle tta fi)
                               else :
                                   (90 if tta<>origin:
                                          -angle direction if l<0: infinity else: 0 fi of pp fi)
                               fi
                                   (tt,tta)
                           else :
                               tt shifted tta
                           fi ;
                    addto axespicture also tt
                        withproperties gpicture.properties ;
                else :
                    pp := pp transformed Txy ;
                fi
                if ticmarklength = 0 : % grid
                    addto thispicture doublepath pp
                        withproperties gpicture.properties ;
                elseif ticmarklength < 0 : % outer tic marks
                    if l<0 :
                        al := arctime -ticmarklength of pp ;
                        addto axespicture doublepath (subpath (0,al) of pp)
                            mirroredabout (point 0 of pp)
                            withproperties gpicture.properties ;
                    elseif l>0 :
                        pp := reverse pp ;
                        al := arctime -ticmarklength of pp ;
                        addto axespicture doublepath (subpath (0,al) of pp)
                            mirroredabout (point 0 of pp)
                            withproperties gpicture.properties ;
                    fi
                else : % inner tic marks
                    if l<0 :
                        al := arctime ticmarklength of pp ;
                        addto axespicture doublepath subpath (0,al) of pp
                            withproperties gpicture.properties ;
                    elseif l>0 :
                        pp := reverse pp ;
                        al := arctime ticmarklength of pp ;
                        addto axespicture doublepath
                            reverse (subpath (0,al) of pp)
                            withproperties gpicture.properties ;
                    fi
                fi
            fi

            % minor tic marks
            save pm ; path pm ;
            for j=1 upto m-1 :
                if xlabel : x := x + d ; exitif x > xmax ;
                    if x >= xmin :
                        pm := if polar_transform :
                                   (x,0)   --(x,ymax)
                               else :
                                   (x,ymin)--(x,ymax)
                               fi ;
                    fi
                else :
                    y := y + d ;
                    exitif y > ymax ;
                    if y >= ymin :
                        pm := if polar_transform :
                                  if y=0 : origin
                                  else :
                                      hide(dx := xmax - xmin ;
                                           def insert_dotdot = hide(def insert_dotdot = .. enddef)
                                               enddef)
                                      for k=0 upto 100 :
                                          insert_dotdot (xmin+dx*k/100,y)
                                      endfor
                                  fi
                              else :
                                  (xmin,y)--(xmax,y)
                              fi ;
                    fi
                fi
                if known pm :
                    pm := transformpath(pm) transformed Txy ;
                    if ticmarklength = 0 : % grid (clipped)
                        addto thispicture doublepath pm
                            withproperties gpicture.properties
                            withpen (penpart gpicture.properties scaled minorpenscale) ;
                    elseif ticmarklength < 0 : % outer tic marks
                        if l<0 :
                            al := arctime (-2ticmarklength/3) of pm ;
                            addto axespicture doublepath (subpath (0,al) of pm)
                                mirroredabout (point 0 of pm)
                                withproperties gpicture.properties ;
                        elseif l>0 :
                            pm := reverse pm ;
                            al := arctime (-2ticmarklength/3) of pm ;
                            addto axespicture doublepath (subpath (0,al) of pm)
                                mirroredabout (point 0 of pm)
                                withproperties gpicture.properties ;
                        fi
                    else : % inner tic marks
                        if l<0 :
                            al := arctime (2ticmarklength/3) of pm ;
                            addto axespicture doublepath subpath (0,al) of pm
                                withproperties gpicture.properties ;
                        elseif l>0 :
                            pm := reverse pm ;
                            al := arctime (2ticmarklength/3) of pm ;
                            addto axespicture doublepath
                                reverse (subpath (0,al) of pm)
                                withproperties gpicture.properties ;
                        fi
                    fi
                fi
            endfor
            t := t + gpicture.factor@# ;
            exitif t>gpicture.tmax@# ;
        endfor
    fi
enddef ;

vardef flushgpicture =
    if length gpicture > 0 :
        save thispicture ; picture thispicture ; thispicture = nullpicture ;

        % first, autoscale if needed, in data space:
        if (unknown xmin) or (unknown ymin) or (unknown xmax) or (unknown ymax) :
            for i within gpicture :
                if stroked i:
                    addto thispicture doublepath
                        (if istextext(i) : textextanchor else : pathpart fi (i))
                        withpen nullpen ;
                elseif filled i :
                    addto thispicture contour
                        (pathpart i) ;
                fi
            endfor

            if unknown xmin :
                if unknown ymin :
                    (xmin,ymin) = llcorner thispicture ;
                else :
                    xmin = xpart llcorner thispicture ;
                fi
            elseif unknown ymin :
                ymin = ypart llcorner thispicture ;
            fi
            if unknown xmax :
                if unknown ymax :
                    (xmax,ymax) = urcorner thispicture ;
                else :
                    xmax = xpart urcorner thispicture ;
                fi
            elseif unknown ymax :
                ymax = ypart urcorner thispicture ;
            fi
        fi
        message("setscale(("& decimal xmin
                        &","& decimal ymin
                      &"),("& decimal xmax
                        &","& decimal ymax
                     &")) ;") ;

        % secondly, determine ranges for tic spacing
        if unknown gpicture.tmin.x :
            if polar_transform :
                (gpicture.tmin.x, gpicture.tmin.y) =              (xmin,ymin) ;
                (gpicture.tmax.x, gpicture.tmax.y) =              (xmax,ymax) ;
            else:
                (gpicture.tmin.x, gpicture.tmin.y) = transformpair(xmin,ymin) ;
                (gpicture.tmax.x, gpicture.tmax.y) = transformpair(xmax,ymax) ;
            fi
message("tmin=("& decimal gpicture.tmin.x &","& decimal gpicture.tmin.y &")") ;
message("tmax=("& decimal gpicture.tmax.x &","& decimal gpicture.tmax.y &")") ;
            find_number.x ;
            find_number.y ;
message("nxy=("& decimal gpicture.number.x &","& decimal gpicture.number.y &")") ;
message("pxy=("& decimal gpicture.power.x  &","& decimal gpicture.power.y &")") ;
message("fxy=("& decimal gpicture.factor.x &","& decimal gpicture.factor.y &")") ;
        fi

        % now, transform, first by coordinates, than by scale
        save Txy ; transform Txy ;
        if polar_transform :
            save polarpath ; path polarpath ;
            polarpath := reverse fullcircle scaled 2ymax rotated 90 ;
            save l ; l := length polarpath ;
            thispicture := nullpicture ;
            addto thispicture doublepath subpath (xmin*l,xmax*l) of polarpath withpen nullpen ;
            addto thispicture doublepath origin withpen nullpen ;
            if llcorner gframe <> origin :
                origin = origin transformed Txy ;
                llcorner gframe = llcorner thispicture transformed Txy ;
                if lrcorner gframe <> origin :
                    lrcorner gframe = lrcorner thispicture transformed Txy ;
                elseif ulcorner gframe <> origin :
                    ulcorner gframe = ulcorner thispicture transformed Txy ;
                else :
                    urcorner gframe = urcorner thispicture transformed Txy ;
                fi
            else :
                for z=llcorner,lrcorner,ulcorner : % origin,right,up
                    z gframed = z thispicture transformed Txy ;
                endfor
            fi
        else :
           %gframe.ll = transformpair(xmin,ymin) transformed Txy ; % origin
           %gframe.lr = transformpair(xmax,ymin) transformed Txy ; % right
           %gframe.ul = transformpair(xmin,ymax) transformed Txy ; % up
           % The above sometimes fails ...
           % The following is more constrained.
            clearxy ;
            z1 = transformpair(xmin,ymin) ;
            z2 = transformpair(xmax,ymax) ;
            Txy = identity xyscaled (gframe.w/(x2-x1),gframe.h/(y2-y1)) ;
            gframe.ll = z1 transformed Txy shifted z0 ;
            Txy := Txy shifted z0 ;
        fi

        thispicture := nullpicture ;

        % draw grid and numbering
        if known gpicture.laboff :
            begingroup
                interim textextoffset := labeloffset ;
                save axespicture ; picture axespicture ;
                axespicture = nullpicture ;
                gridandnumbers.x(Txy) ;
                gridandnumbers.y(Txy) ;
                if length axespicture > 0 :
                    addto currentpicture also axespicture ; % not clipped!
                fi
            endgroup ;
        fi

        % now, redraw each item
        for i within gpicture :
            if filled i :
                message "filled" ;
                addto thispicture contour
                    transformpath(pathpart i) transformed Txy
                    withproperties i ;
            elseif stroked i :
                message "stroked" ;
                if length prescriptpart i = 0 : % a path
                    addto thispicture doublepath
                        transformpath(pathpart i) transformed Txy
                        withproperties i ;
                else : % text, symbol, error bar, ...
                    message prescriptpart i ;
                    if istextext(i) :
                        clearxy ; z = textextanchor(i) ;
                        addto thispicture also
                            i shifted ((transformpair(x,y) transformed Txy) - z)
                            withproperties i ;
                        message (redpart i, greenpart i, bluepart i) ;
                    elseif isgraphsymbol(i) :
                        for n = runscript lgid_plotsymbol (prescriptpart i) :
                            save pic ; picture pic ;
                            if numeric n :
                                message "numeric "&decimal n ;
                                pic = graphsymbolpicture[n] ;
                            elseif string n :
                                message "string "&n ;
                                pic = scantokens("graphsymbolpicture."&n) ;
                            elseif pair n : % a picture pushed on a stack...
                                message n ; % (incomplete for now)
                                clearxy ; z = n ;
                                if known  gpicture.graphpicture[x] :
                                    pic = gpicture.graphpicture[x] scaled y ;
                                fi 
                            elseif n :
                                message "errorbars" ; % todo
                            else :
                                message n ;
                            fi
                            if known pic :
                                save p ; path p ;
                                p = transformpath(pathpart i) transformed Txy ;
                                for j inpath p :
                                    addto thispicture also pic shifted pointof j ;
                                endfor
                            fi
                        endfor
                    fi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                    for n = runscript lgid_plotsymbol prescriptpart i :
%                        message (n) ;
%                        if boolean n:
%                            % should only be false
%                            addto thispicture also
%                                if istextext(i) :
%                                    clearxy ; z = textextanchor(i) ;
%                                    i shifted (transformpair(x,y) transformed Txy) - z
%                                    withproperties i ;
%                                else : % arrows (todo)
%                                   %image(           runscript("mp.drawcommand(prescriptpart i)")
%                                   %image(scantokens(runscript("mp.drawcommand(prescriptpart i)")
%                                    image(scantokens(       lua.mp.drawcommand(prescriptpart i)
%                                          transformpath(pathpart i)
%                                          transformed Txy
%                                          withproperties i)) ;
%                                fi
%                        else : % numeric or string
%                            save suffixstring ; string suffixstring ;
%                            suffixstring =
%                                if numeric n : 
%                                    if n<0 : "["&decimal n&"]" ;
%                                    else   :     decimal n ; fi
%                                elseif substring (0,1) of n = "{" :
%                                    ".tempstring" ;
%                                    save tempstring ; string tempstring;
%                                    tempstring := n ;
%                                else : "."&n ; fi
%                            save pic ; picture pic ; pic = nullpicture ;
%                            for j within scantokens("graphsymbolpicture"&suffixstring) :
%                                addto pic also j
%                                    withproperties i
%                                    if (colorpart j) = background :
%                                         withcolor background
%                                    fi ;
%                            endfor
%                            save p ; path p ;
%                            p = transformpath(pathpart i) transformed Txy ;
%                            for j inpath p :
%                                addto thispicture also pic shifted pointof j ;
%                            endfor
%                        fi
%                    endfor
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                fi
            fi
        endfor
    
        if length thispicture > 0 :
            clip thispicture to gframe ;
            addto currentpicture also thispicture ;
        fi
    
        gpicture := nullpicture ;
    fi
enddef ;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%vardef autogrid@#(text e) text t =
%    pair gpicture.laboff ;
%    gpicture.laboff := mfun_laboff@# ;
%    save m ; numeric m[] ; m = 0 ;
%    for i=e :
%        if known i :
%            m[m] = if i=0: 1 else: i fi ;
%                    endgroup ;
%                fi
%                   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                   %begingroup
%                   %save s ; string s ; s = runscript plotsymbol prescriptpart i ;
%                   %message s ;
%                   %save pic ; picture pic ;
%                   %pic = image(draw textext(s) withproperties i) ;
%                   %save p ; path p ;
%                   %p = transformpath(pathpart i) transformed Txy ;
%                   %for j inpath p :
%                   %    addto thispicture also pic shifted (pointof j) ;
%                   %endfor
%                   %endgroup ;
%                   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%            fi
%        endfor
%    
%        if length thispicture > 0 :
%            clip thispicture to gframe ;
%            addto currentpicture also thispicture ;
%        fi
%    
%        gpicture := nullpicture ;
%    fi
%enddef ;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

vardef autogrid@#(text e) text t =
    pair gpicture.laboff ;
    gpicture.laboff := mfun_laboff@# ;
    save m ; numeric m[] ; m = 0 ;
    for i=e :
        if known i :
            m[m] = if i=0: 1 else: i fi ;
        fi
        m := m + 1 ;
    endfor
    if (m=1) and (known m0) : m1 := m0 ; fi
    if known m0 : gpicture.minor.x := m0 ; fi
    if known m1 : gpicture.minor.y := m1 ; fi
    picture gpicture.properties ; gpicture.properties := image(draw origin t) ;
enddef ;

def setscale(text t) =
    if unknown gpicture :
        message "setscale() must be called within a graph" ;
    else :
        flushgpicture ;
        save gpicture ; picture gpicture ; gpicture = nullpicture ;
    
        begingroup
            save j ; j = 0 ; numeric j[] ;
            for i=t :
                if cmykcolor i :
                    (j0,j1,j2,j3) = i ;
                    j := 4
                elseif pair i :
                    (j[j],j[j+1]) = i ;
                    j := j + 2 ;
                elseif numeric i :
                    j[j] = i ;
                    j := j+1 ;
                elseif string i :
                    if j>0 : message "Warning!" ; fi
                    setcoordinates(t) ;
                    exitif true ;
                else :
                    message "setscale: ?" ;
                fi
                exitif j>3 ;
            endfor
            if j>3 :
                (xmin,ymin,xmax,ymax) = (j0,j1,j2,j3) ;
            fi
        endgroup ;
    fi
enddef ;

def gfill expr c =
    gpath := c ; addto gpicture contour gpath base_draw_options
enddef ; 

def gfilldraw expr c =
    gpath := c ; addto gpicture contour gpath withpen currentpen base_draw_options
enddef ;

primarydef a withsymbol s =
    if picture a :
        image(for i within a :
            draw i
    else :
        a
    fi
        if known s :
            if    numeric s :
                withprescript "gr_symbol_d=" & decimal s
            elseif string s :
                withprescript "gr_symbol_s=" & s
            elseif picture s :
                hide(if unknown gpicture.graphsymbol :
                         gpicture.graphsymbol = -1 ;
                         picture gpicture.graphsymbol[] ;
                     fi
                     gpicture.graphsymbol[incr gpicture.graphsymbol] = s)
                if known gpicture.graphsymbol :
                    withprescript "gr_symbol_p=" & decimal gpicture.graphsymbol
                fi
            fi
        else :
            hide(message "Warning: unknown symbol" ;)
        fi
    if picture a :
                   ;
              endfor
              )
    fi
enddef ;

def gdraw expr p =
    if picture p :
        addto gpicture also p
        base_draw_options
    elseif (string p) or (path p) :
        gpath := 
            if path p :
                p
            else : % runscript?
                hide(save n ; n := lua.mp.CSVDataLoad(p) ; message n)
                lua.mp.CSVDataPath(p)
            fi ;
        addto gpicture doublepath gpath withpen currentpen
        base_draw_options
    fi
enddef ;

def gdrawarrow        text t = gdraw t withprescript "gr_draw=drawarrow"        enddef ;
def gdrawdblarrow     text t = gdraw t withprescript "gr_draw=drawdblarrow"     enddef ;
def gdrawdoublearrows text t = gdraw t withprescript "gr_draw=drawdoublearrows" enddef ;

def gplot expr p = gdraw p withsymbol 0 enddef ;

vardef glabel@#(expr s,z) text t_ =
    save p ; pair p ; p := if numeric z : point z of gpath else : z fi ;
    gdraw thetextext@#(s,p) t_ ;
enddef ;

vardef gdotlabel@#(expr s,z) text t_ =
    save p ; pair p ; p := if numeric z : point z of gpath else : z fi ;
    glabel@#(s,p) t_ ;
    interim linecap := rounded ;
    gdraw p withpen pencircle scaled dotlabeldiam t_ ;
enddef ;

% polynomial : y = sum_{i=0}^n $i*x^i

vardef polynomial@#(expr n)(suffix $)(expr x) =
    if numeric x :
        for i=0 upto n-1 : +$[i]*(x**i) endfor
    elseif path x :
        hide(save p ; path p ; p = x)
        polynomial.p(n,$,false)
    else :
       if str @# <> "" :
           if path @# : 
               hide(save x_i ; def insert_dotdot=hide(def insert_dotdot=..enddef)enddef)
               for i inpath @# :
                   hide(x_i := xpart pointof i)
                   insert_dotdot (x_i,polynomial(n,$,x_i))
               endfor if cycle @# : insert_dotdot cycle fi
           fi
       fi
    fi
enddef ;

% least-squares fit of a polynomial order p-1 (p terms)
%
% P. R. Bevington, "Data Reduction and Error Analysis for the
% Physical Sciences", McGraw-Hill, New York 1969, pp. 140-143.

vardef polynomialfit@#(expr n, w) =
    if path @# :
        runscript("mp.polynomialFit(" & decimal n & "," &
                         if numeric w : decimal fi w & ")") @#
    else :
        origin
    fi
enddef ;

def fitChiSq =  lua.mp.FitChiSq() enddef ;
def fitC(expr n) = lua.mp.FitC(n) enddef ;

% exponential a1 = exp(a0 * x) + a2

vardef exponential@#(suffix $)(expr x) =
    if numeric x :
        $1*exp($0 * x) if known $2 +$2 fi
    elseif path x :
        hide(save p ; path p ; p = x)
        exponential.p($,false)
    else :
       if str @# <> "" :
           if path @# : 
               hide(save x_i ; def insert_dotdot=hide(def insert_dotdot=..enddef)enddef)
               for i inpath @# :
                   hide(x_i := xpart pointof i)
                   insert_dotdot (x_i,exponential($,x_i))
               endfor if cycle @# : insert_dotdot cycle fi
           fi
       fi
    fi
enddef ;

% As we take a log, this only works for positive ordinates

vardef exponentialfit@#(suffix $, chisq) =
    if known $2 :
        hide(messagee "exponentialfit: subtracting constant "&decimal $2 ;)
        runscript("mp.exponentialFit(str @#,str $,str chisq,decimal $2)")
    else :
        runscript("mp.exponentialFit(str @#,str $,str chisq)")
    fi
enddef ;


% As we take a log, this only works for positive ordinates

vardef Gaussianfit@#(suffix $, chisq) =
    if known $3 :
        hide(message "Gaussianfit: subtracting constant "&decimal $3 ;)
        runscript("mp.GaussianFit(str @#,str $,str chisq,decimal $3)")
    else :
        runscript("mp.GaussianFit(str @#,str $,str chisq):")
    fi
enddef ;

% Gaussian : y = a2 * exp(-ln(2)*((x-a0)/a1)^2)
%
% a1 is the hwhm ; sigma := a1/sqrt(2ln(2)) or a1/1.17741

newinternal lntwo ;               lntwo := 0.693147180559945309417232121458176568 ; % ln(2) ;
newinternal sqrttwolntwo ; sqrttwolntwo := 1.177410022515474663507006880536209792 ; % sqrt(2ln(2)) ;

vardef Gaussian@#(suffix $)(expr x) =
    if numeric x :
        if $1 = 0 : % zero width -> delta function
            if x = $0 : $2 else : 0 fi
        else :
            $2 * exp(-lntwo*(((x-$0)/$1)**2))
        fi
        if known $3 :
            + $3
        fi
    elseif path x :
        hide(save p ; path p ; p = x)
        Gaussian.p($,false)
    else :
       if str @# <> "" :
           if path @# : 
               hide(save x_i ; def graph_dotdot=hide(def graph_dotdot=..enddef)enddef)
               for i inpath @# :
                   hide(x_i := xpart pointof i)
                   graph_dotdot (x_i,Gaussian($,x_i))
               endfor if cycle @# : graph_dotdot cycle fi
           fi
       fi
    fi
enddef ;

vardef Lorentzianfit@#(suffix $, chisq) =
    if known $3 :
        hide(message "Lorentzianfit: subtracting constant "&decimal $3 ;)
        runscript("mp.LorentzianFit(str @#,str $,str chisq,decimal $3)")
    else :
        runscript("mp.LorentzianFit(str @#,str $,str chisq):")
    fi
enddef ;

% Lorentzian: y = a2 / (1 + ((x - a0)/a1)^2)

vardef Lorentzian@#(suffix $)(expr x) =
    if numeric x :
        if $1 = 0 : % zero width -> delta function
            if x = $0 : $2 else : 0 fi
        else :
            $2 / (1 + ((x - $0)/$1)**2)
        fi
        if known $3 :
            + $3
        fi
    elseif path x :
        hide(save p ; path p ; p = x)
        Lorentzian.p($,false)
    else :
       if str @# <> "" :
           if path @# : 
               hide(save x_i ; def graph_dashdash=hide(def graph_dashdash=--enddef)enddef)
               for i inpath @# :
                   hide(x_i := xpart pointof i)
                   graph_dashdash (x_i,Lorentzian($,x_i))
               endfor if cycle @# : graph_dashdash cycle fi
           fi
       fi
    fi
enddef ;
