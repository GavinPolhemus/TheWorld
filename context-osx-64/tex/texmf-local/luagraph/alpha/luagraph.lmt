if not modules then modules = { } end modules ['newgraph'] = {
    version   = 1.000,
    comment   = "companion to m-newgraph.mkiv",
    author    = "Alan Braslau with help from Hans Hagen",
    copyright = "PRAGMA ADE / ConTeXt Development Team",
   license   = "see context related readme files"
}

local pi    = math.pi
local twopi = 2*pi
local sin   = math.sin
local cos   = math.cos
local ln    = math.log   -- attention to names!
local log   = math.log10 -- attention to names!
local log2  = math.log2  -- attention to names!
local exp   = math.exp
local sqrt  = math.sqrt
local atan  = math.atan

-- We need a log function that is robust and can handle negative data.

local logmin = 0 -- seed

local function lg(x)
    if x<=0 then
        return logmin
    end
    local l = log(x)
    if l<logmin then logmin = l end
    return l
end

local log2min = 0 -- seed

local function lg2(x)
    if x<=0 then
        return log2min
    end
    local l = log2(x)
    if l<log2min then log2min = l end
    return l
end

local aux         = mp.aux
local mpprint     = aux.print
local mpquoted    = aux.quoted
local mppair      = aux.pair
--local mppath      = aux.path
local mppath      = mp.path  -- which one?

-- Does this work in lmtx?
--local get          = mp.get
--local mpgetnumeric = get.numeric

local scan        = mp.scan
local scannumeric = scan.numeric
local scanstring  = scan.string
local scanpair    = scan.pair
local scanpath    = scan.path
local scansymbol  = scan.symbol

-- how are these used?
--local inject      = mp.inject
--local injectpair  = inject.pair
--local injectpath  = inject.path

local registerscript = metapost.registerscript


local tostring, tonumber = tostring, tonumber -- register efficiency?
local find, match = string.find, string.match
local osdate, ostime = os.date, os.time
local replacer    = lpeg.replacer("@","%%")
local lpegmatch   = lpeg.match

function mp.Date(f,d)
    if not find(f,"%",1,true) then
        f = lpegmatch(replacer,f)
    end
    mpquoted(osdate(f,tonumber(d))) -- returns a string to scantokens
end

-- the following function is not used, at present

function mp.Time(year,month,day,hour,minute,second)
    local t = {
                year=  tonumber(year) or 0,
                month= tonumber(month) or 0,
                day=   tonumber(day) or 0,
                hour=  tonumber(hour) or 0,
                minute=tonumber(minute) or 0,
                second=tonumber(second) or 0,
              }
    mpprint(ostime(t)) -- returns a number to scantokens
end

registerscript("plotsymbol", function()
    local t = metapost.splitprescript(scanstring() or "")
  --inspect(t)

    if     t.gr_symbol_s then
        mpquoted(t.gr_symbol_s)
    elseif t.gr_symbol_d then
        mpprint(t.gr_symbol_d)
    elseif t.gr_symbol_p then
        local scale = 1 -- reserved for future use
        mppair(t.gr_symbol_p,scale)
    elseif t.gr_symbol_none then -- used for errorbars
        mpprint(true)
    else
        mpprint(false)
    end
end)

-- used for arrows

function mp.drawcommand(s)
    local cmd = match(s,"gr_draw=(%S+)")
    mpprint(cmd or "draw")
end

-- tweak the format functions from core-con.lua

local formatters     = string.formatters
local addformatter   = utilities.strings.formatters.add

local f_month        = formatters["\\month{%s}"]
local f_monthshort   = formatters["\\monthshort{%s}"]
local f_weekday      = formatters["\\weekday{%s}"]

local function tomonth(m)
    return f_month(((tonumber(m) or 1)-1)%12+1)
end

local function tomonthshort(m)
    return f_monthshort(((tonumber(m) or 1)-1)%12+1)
end

local function toweekday(d)
    return f_weekday(((tonumber(d) or 1)-1)%7+1)
end

addformatter(formatters,"month",       [[tomonth(%s)]],             { tomonth        = tomonth        })
addformatter(formatters,"monthshort",  [[tomonthshort(%s)]],        { tomonthshort   = tomonthshort   })
addformatter(formatters,"weekday",     [[toweekday(%s)]],           { toweekday      = toweekday      })


-- The core of this lua part is the transformation
-- between coordinate systems.

local coordinates = ""
local scale       = 1
local fn          = nil
local primaries   = { }
local pairs       = { }
local minors      = { }

pairs[""] = { "Lin", "Lin" } -- default

do
    local t = { "Lin", "Log", "Ltwo", "Sqrt", "Date", }
    local m = { 1,     9,     1,      1,      1,      }
    for i=1,#t do
        local ti = t[i]
        primaries[ti] = true
        for j=1,#t do
            local tj = t[j]
            pairs [ti..tj] = { ti, tj }
            minors[ti..tj] = { m[i], m[j] }
        end
    end
end

function mp.minorpair()
    local m = minors[coordinates] or { 1, 1 }
    mppair(m[1],m[2])
end

--       transformLinLin is a nop and should only be used for debugging!

function transformLinLin(x,y,inverse)
  --if inverse then
  --    return x, y
  --end
    return x, y
end

function transformLinLog(x,y,inverse)
    if inverse then
        return x, 10^y
    end
    return x, lg(y)
end

function transformLinLtwo(x,y,inverse)
    if inverse then
        return x, 2^y
    end
    return x, lg2(y)
end

function transformLinSqrt(x,y,inverse)
    if inverse then
        return x, y*y
    end
    if y<=0 then
        return x, 0
    end
    return x, sqrt(y)
end

function transformLogLin(x,y,inverse)
    if inverse then
        return 10^x, y
    end
    return lg(x), y
end

function transformLtwoLin(x,y,inverse)
    if inverse then
        return 2^x, y
    end
    return lg2(x), y
end

function transformLogLog(x,y,inverse)
    if inverse then
        return 10^x, 10^y
    end
    return lg(x), lg(y)
end

function transformLtwoLtwo(x,y,inverse)
    if inverse then
        return 2^x, 2^y
    end
    return lg2(x), lg2(y)
end

function transformLogSqrt(x,y,inverse)
    if inverse then
        return 10^x, y*y
    end
    if y<=0 then
        return lg(x), 0
    end
    return lg(x), sqrt(y)
end

function transformLtwoSqrt(x,y,inverse)
    if inverse then
        return 2^x, y*y
    end
    if y<=0 then
        return lg2(x), 0
    end
    return lg2(x), sqrt(y)
end

function transformSqrtLin(x,y,inverse)
    if inverse then
        return x*x, y
    end
    if x<0 then
        return 0, y
    end
    return sqrt(x), y
end

function transformSqrtLog(x,y,inverse)
    if inverse then
        return x*x, 10^y
    end
    if x<0 then
        return 0, lg(y)
    end
    return sqrt(x), lg(y)
end

function transformSqrtLtwo(x,y,inverse)
    if inverse then
        return x*x, 2^y
    end
    if x<0 then
        return 0, lg2(y)
    end
    return sqrt(x), lg2(y)
end

function transformSqrtSqrt(x,y,inverse)
    if inverse then
        return x*x, y*y
    end
    if y<=0 then
        if x<0 then
            return 0, 0
        end
        return sqrt(x), 0
    end
    return sqrt(x), sqrt(y)
end

-- polar coordinates
-- note that this runs clockwise from North
-- (contrary to MP, were angles run counterclockwise from East)

function transformPolar(theta,r,inverse)
    -- units: theta [0,scale] (modulo scale)
    if inverse then
        local x, y = theta, r
        r = sqrt(x*x + y*y)
        if r == 0 then
            return 0, 0
        end
        x = x / r
        y = y / r
        theta = scale * atan(x,y) / twopi
        return theta, r
    end
    if r == 0 then
        return 0, 0
    end
    theta = twopi*theta/scale
    return r*sin(theta), r*cos(theta)
end

local functions  = {
    LinLin   = transformLinLin,
    LinLog   = transformLinLog,
    LinLtwo  = transformLinLtwo,
    LinSqrt  = transformLinSqrt,
    LogLin   = transformLogLin,
    LogLog   = transformLogLog,
    LtwoLtwo = transformLtwoLtwo,
    LogSqrt  = transformLogSqrt,
    SqrtLin  = transformSqrtLin,
    SqrtLog  = transformSqrtLog,
    SqrtLtwo = transformSqrtLtwo,
    SqrtSqrt = transformSqrtSqrt,
    -- todo: Date
    Polar    = transformPolar,
} 

--function mp.settransform(name, s)
--    coordinates  = name
--    scale        = s
--    fn = functions[name] -- or nil
--
--    mpprint("") -- return a null string to scantokens
--end

registerscript("settransform", function()
    coordinates = scanstring()
inspect("coordinates="..coordinates)

    local t = { }
    if pairs[coordinates] then
        t = pairs[coordinates]
    end
inspect(t)

    local s = scansymbol()
inspect("scansymbol->"..s)
    if s == "(" then
        local i = 1
        while true do
            s = scansymbol()
            if s then
inspect("scansymbol->"..s)
            else
                local n = scannumeric()
inspect("scannumeric->"..tostring(n))
            end
            if s == ")" then
                break;
            elseif s == "," then
                i = i + 1
                -- next token
            elseif s and s ~= "" then
                if primaries[s] then
                    t[i] = s
                elseif pairs[s] then
                    t = pairs[s]
                    i = 2
                elseif tonumber(s) then
                    scale = tonumber(s)
                else
                    t[1] = s
                    t[2] = nil
                end
            end
        end
    elseif tonumber(s) then
        scale = tonumber(s)
    else
        t[1] = s
        t[2] = nil
    end
inspect(t)
inspect("scale="..tostring(scale))

    -- this interpretation may evolve...
    if t[1] and t[2] then
        coordinates = t[1]..t[2]
    elseif t[1] then
        coordinates = t[1]
    end
inspect("coordinates="..coordinates)
    
    fn = functions[coordinates]
    return  '"' .. coordinates .. '"'
end)

local function transformpair(x,y,inverse)
    if fn then
        x,y = fn(x,y,inverse)
    end
    return x,y 
end

registerscript("transformPair", function()
    x,y = scanpair()
    mppair(transformpair(x,y))
end)

registerscript("transformPairInverse", function()
    local x,y = scanpair()
    mppair(transformpair(x,y,true))
end)

registerscript("transformPath", function()
    local path = scanpath()

    -- MP correspondance:
    -- (p[i][1],p[i][2])..controls(p[i][5],p[i][6])and(p[i+1][3],p[i+1][4])..
    -- if i == n then                                   (p[1][3],p[1][4])

    if fn then
        local n = #path or 0
        local p
        if n==1 then
            p = path[1]
            p[1], p[2] = fn(p[1], p[2])
            p[3], p[4] = nil, nil
            p[5], p[6] = nil, nil
        else
            for i=1,n do
                p = path[i]
                p[1], p[2] = fn(p[1], p[2])
                p[3], p[4] = fn(p[3], p[4])
                p[5], p[6] = fn(p[5], p[6])
            end
        end
    end
    mppath(path)
end)

-- Alan: check this!

function mp.binPath(binsize,stdscale)
    local path = scanpath()
    local n = path and #path or 0
    local cycle = path and path.cycle or false
if cycle then
  inspect(path[1])
  inspect(path[n])
end
    local t,s = { },{ }
    local j,k = 0,0
    local sum = { 0,0,0,0 }
    for i=1,n do
        local pathi = path[i]
        local x,y = pathi[1],pathi[2]
        sum = { sum[1]+x,
                sum[2]+y,
                sum[3]+x*x,
                sum[4]+y*y }
        k = k + 1
        if (k == binsize) or (i==n) then
            j = j + 1
            local sx,sy = sum[1],sum[2]
            t[j] = { sx/k, sy/k }
            s[j] = { sqrt(sum[3]*k - sx*sx) / k,
                     sqrt(sum[4]*k - sy*sy) / k }
            k = 0
            sum = { 0,0,0,0 }
        end
    end
    if stdscale then
        stdscale = tonumber(stdscale) or 1
        if stdscale == 0 then -- return variance path
            mppath(s,"--",path.cycle)
        else -- returns a picture
            mpprint("image(")
            for i=1,#t do
                local ti,si = t[i],s[i]
                local x,y,sx,sy = ti[1],ti[2],si[1],si[2]
                if stdscale > 0 then -- error bars
                    if stdscale ~= 1 then
                        sx,sy = sx*stdscale,sy*stdscale
                    end
                    if (sy ~= 0) then
                        mpprint("draw ")
                        mppair(x,y-sy); mpprint("--"); mppair(x,y+sy);
                        mpprint(";")
                    end
                    if (sx ~= 0) then
                        mpprint("draw ")
                        mppair(x-sx,y); mpprint("--"); mppair(x+sx,y);
                        mpprint(";")
                    end
                else -- error ellipse
                    if stdscale ~= -1 then
                        sx,sy = -stdscale*sx,-stdscale*sy
                    end
                    if (sx ~= 0) and (sy ~= 0) then
                        mpprint("fill (fullcircle xyscaled "); mppair(2*sx,2*sy)
                        mpprint(") shifted "); mppair(x,y); mpprint(";")
                    end
                    mpprint("draw ");          mppair(x,y); mpprint(";")
                end
            end
            mpprint(")")
        end
    else -- returns a path
        if #t == 0 then -- return the origin for sanity
            t[1] = { 0,0 }
        end
        mppath(t,"--",cycle)
    end
end

-- Least-squares "fit" (to a polynomial)
--
-- reference : P. R. Bevington, "Data Reduction and Error Analysis for the
-- Physical Sciences", McGraw-Hill, New York 1969.

local function Determinant(m)
    -- m is a table n*n
    local n = #m

    -- The first three cases are easy and best returned explicitly.
    if n == 1 then
        local m1 = m[1]
        assert(n == #m1, "Not a square matrix!")
        return m1[1]
    end
    if n == 2 then
        local m1, m2 = m[1], m[2]
        assert(n == #m1 and n == #m2, "Not a square matrix!")
        return m1[1]*m2[2] - m2[1]*m1[2]
    end
    if n == 3 then
        local m1, m2, m3 = m[1], m[2], m[3]
        assert(n == #m1 and n == #m2 and n == #m3, "Not a square matrix!")
        return(m1[1]*m2[2]*m3[3]
              +m1[2]*m2[3]*m3[1]
              +m1[3]*m2[1]*m3[2]
              -m1[3]*m2[2]*m3[1]
              -m1[1]*m2[3]*m3[2]
              -m1[2]*m2[1]*m3[3])
    end

    -- n > 3, we use a general algorithm to calculate the determinant
    -- adapted from Bevington (1969), p.294
    -- (note: modifies the input matrix, m)

    local determinant = 1
    for k=1,n do
        local mk = m[k]
        assert(n == #mk, "Not a square matrix!")
        local mkk = mk[k]
        if mkk==0 then -- diagonal element is zero
            local i = nil
            for j=k+1,n do
                if mk[j] ~= 0 then
                    i = j
                    break
                end
            end
            if not i then return 0 end
            -- interchange the columns
            for j=k,n do
                local mj = m[j]
                mj[k], mj[i] = mj[i], mj[k]
            end
            determinant = -determinant
        end  
        determinant = determinant * mkk
        -- subtract row k from lower rows to get a diagonal matrix
        for j=k+1,n do
            local mj = m[j]
            for i=k+1,n do
                mj[i] = mj[i]-mj[k]*mk[i]/mkk
            end
        end
    end
    return determinant
end

-- invert a symmetric matrix and calculate its determinant

-- todo:
-- local function MatrixInversion(m)
--     local n = #m
-- 
--     -- adapted from Bevington (1969), p.302-303
-- 
--     local determinant = 1
--     -- find the largest element
--     for k=1,n do
--         local max = 0
--         for i=1
--     end
-- end

-- least-squares fit of a polynomial order p-1 (p terms) to a table xys
-- Bevington (1969), pp. 140-143

local function polynomialFit(p,xys,mode)
    -- cannot fit a polynomial of order greater than the number of points
    if p>=#xys then p = #xys-1 end

    local function weight(y,s) return 1 end
    if mode then
        if mode=="inverse" then
            local function weight(y,s) return y end
        elseif mode=="logarithmic" then
            local function weight(y,s) return exp(y) end
        elseif mode=="statistical" then
            local function weight(y,s) return y==0 and 1 or y>0 and 1/y or -1/y end
        elseif mode=="instrumental" then
            local function weight(y,s) return s==0 and 1 or 1/s^2 end
      --else
      --    local function weight(y,s) return 1 end
        end
  --else
  --    local function weight(y,s) return 1 end
    end

    -- accumulate weighted sums
    local sumx = { }
    local pmax = 2*p - 1
    for i=1,pmax do
        sumx[i] = 0
    end
    local sumy = { }
    for i=1,p do
        sumy[i] = 0
    end
    local chiSquared = 0
    for i=1,#xys do
        local xys_i = xys[i]
        -- assume, don't check, that #xys_i > 1
        local x_i, y_i, s_i = xys_i[1], xys_i[2], xys_i[3] or 0
        local w = weight(y_i,s_i)
        local x = w
        for i=1,pmax do
            sumx[i] = sumx[i] + x
            x = x*x_i
        end
        local y = w*y_i
        for i=1,p do
            sumy[i] = sumy[i] + y
            y = y*x_i
        end
        chiSquared = chiSquared + w*y_i^2 ;
    end

    -- construct matrices and calculate coefficients
    local m = { }
    for j=1,p do
        m[j] = { }
        local mj = m[j]
        for k=1,p do
            mj[k] = sumx[j+k-1]
        end
    end
    local coefficients = { }
    local delta = Determinant(m)
    if delta==0 then
        for i=1,p do
            coefficients[i] = 0
        end
        chiSquared = 0
        return chiSquared, coefficients
    end
    for i=1,p do
        for j=1,p do
            local mj = m[j]
            for k=1,p do
                mj[k] = sumx[j+k-1]
            end
            mj[i] = sumy[j]
        end
        coefficients[i] = Determinant(m) / delta
    end

    -- calculate chi squared
    for j=1,p do
        local cj = coefficients[j]
        chiSquared = chiSquared - 2*cj*sumy[j]
        for k=1,p do
            chiSquared = chiSquared + cj*coefficients[k]*sumx[j+k-1]
        end
    end
    -- normalize by the number of degrees of freedom
    chiSquared = chiSquared / (#xys - p)

    return chiSquared, coefficients
end

-- multiple regression, any function linear in its coefficients
-- Bevington (1969) pp. 172-175.

-- todo:
-- local function regression(p,xys,mode)
--     -- cannot fit a function of order greater than the number of points
--     if p>=#xys then p = #xys-1 end
-- 
--     local sum, ymean, sigma, chiSquared, rmul, ftest = 0, 0, 0, 0, 0
--     local yfit = { }
--     local sigmaA = { }
-- 
--     local function weight(y,s) return 1 end
--     if mode then
--         if mode=="inverse" then
--             local function weight(y,s) return y end
--         elseif mode=="logarithmic" then
--             local function weight(y,s) return exp(y) end
--         elseif mode=="statistical" then
--             local function weight(y,s) return y==0 and 1 or y>0 and 1/y or -1/y end
--         elseif mode=="instrumental" then
--             local function weight(y,s) return s==0 and 1 or 1/s^2 end
--       --else
--       --    local function weight(y,s) return 1 end
--         end
--   --else
--   --    local function weight(y,s) return 1 end
--     end
-- 
--     -- accumulate weighted sums
-- 
-- 
-- 
--     return chiSquared, coefficients
-- end

local function polynomialFunction(c,x)
    x = tonumber(x) or 0
    local xp = 1
    local  y = c[1]
    for i=2,#c do
        xp = xp*x
        y  = y + c[i]*xp
    end
    return y
end

-- We keep the least-squares "fit" chisq
-- as well as the coefficients c internally
-- making them accessible if needed through functions.

local chisq, c = { }

function mp.FitChiSq() mpprint(chisq) end

function mp.FitC(i)
    if i < 0 then -- a negative index returns the number of parameters
        mpprint(#c)
    else -- we index starting at 0, more like MP (and C...)
        mpprint(c[i+1] or 0) -- return 0 rather than nil or ""
    end
end

-- use: runscript("mp.polynomialFit(p,w)") path
-- see mp-luag.mpiv

function mp.polynomialFit(p,w)
    local path = scanpath()

    local n = path and #path or 0
    local t = { }
    for i=1,n do
        local p_i = path[i]
        t[i] = { p_i[1], p_i[2] }
    end
    chisq, c = polynomialFit(p,t,w)
inspect(chisq,c)

    for i=1,n do
        local t_i = t[i]
        local x   = t_i[1]
        t_i[2] = polynomialFunction(c,x)
    end
    t.cycle = path.cycle
    mppath(t,"--")
end

-- $y = a_2 \exp(a_1 x) + a_3$
-- A straight line in linlog coordinates

local function exponentialFunction(c,x)
          x = tonumber(x) or 0
    local p = tonumber(c[1]) or 1
    local A = tonumber(c[2]) or 1
    local c = tonumber(c[3]) or 0
    return A*exp(p*x) + c
end

function mp.exponentialFit(name,coefs,csq,cst)
    cst = tonumber(cst) or 0

    local path = scanpath(name)
    local n = path and #path or 0
    local t = { }
    local j = 1
    for i=1,n do
        local p_i = path[i]
        local x = p_i[1]
        local y = p_i[2] - cst
        if y>0 then -- skip points where ordinate is negative
            t[j] = { x, ln(y) }
            j = j + 1
        end
    end
    local chisq, a = polynomialFit(2,t,"logarithmic")
    local c = { }
    c[1] = a[2]
    c[2] = exp(a[1])
    if coefs and csq then
        chisq = exp(sqrt(chisq))
        chisq = chisq * chisq
        mpprint("hide(")
            mpprint(csq..":="..tostring(chisq)..";")
            for i=1,#c do
                mpprint(coefs..tostring(i-1)..":="..tostring(c[i])..";")
            end
        mpprint(")")
    end
    for i=1,#t do
        local t_i = t[i]
        local x  = t_i[1]
        t_i[2] = exponentialFunction(c,x)
    end
    t.cycle = path.cycle
    mppath(t,"--")
end

-- $y = a_2 x^a_1$
-- A straight line in loglog coordinates

local function powerlawFunction(c,x)
          x = tonumber(x) or 0
    local p = tonumber(c[1]) or 1
    local A = tonumber(c[2]) or 1
    return A*x^p
end

function mp.powerlawFit(name,coefs,csq)
    local path = scanpath(name)
    local n = path and #path or 0
    local t = { }
    local j = 1
    for i=1,n do
        local p_i = path[i]
        local x = p_i[1]
        local y = p_i[2]
        if y>0 then -- skip points where ordinate is negative
            t[j] = { ln(x), ln(y) }
            j = j + 1
        end
    end
    local chisq, a = polynomialFit(2,t,"logarithmic")
    local c = { }
    c[1] = a[2]
    c[2] = exp(a[1])
    if coefs and csq then
        chisq = exp(sqrt(chisq))
        chisq = chisq * chisq
        mpprint("hide(")
            mpprint(csq..":="..tostring(chisq)..";")
            for i=1,#c do
                mpprint(coefs..tostring(i-1)..":="..tostring(c[i])..";")
            end
        mpprint(")")
    end
    for i=1,#t do
        local t_i = t[i]
        local x  = t_i[1]
        t_i[2] = powerlawFunction(c,x)
    end
    t.cycle = path.cycle
    mppath(t,"--")
end

-- Gaussian : y = a3 * exp(-ln(2)*((x-a1)/a2)^2) + a4
-- a2 is the hwhm ; sigma = a2/sqrt(2ln(2)) or a2/1.17741

local ln2      = 0.693147180559945309417232121458176568 -- ln(2)
local sqrt2ln2 = 1.177410022515474663507006880536209792 -- sqrt(2ln(2))

local function GaussianFunction(c,x)
             x = tonumber(x) or 0
    local x0   = tonumber(c[1]) or 0
    local hwhm = tonumber(c[2]) or 1
    local A    = tonumber(c[3]) or 1
    local cst  = tonumber(c[4]) or 0
    if hwhm == 0 then -- return a delta function
        if x == x0 then
            return A + cst
        end
        return cst
    end
    return A*exp(-ln2*((x-x0)/hwhm)^2) + cst
end

function mp.GaussianFit(name,coefs,csq,cst)
    cst = tonumber(cst) or 0

    local path = scanpath(name)
    local n = path and #path or 0
    local t = { }
    local j = 1
    for i=1,n do
        local p_i = path[i]
        local x = p_i[1]
        local y = p_i[2] - cst
        if y>0 then -- skip points where ordinate is negative
            t[j] = { x, ln(y) }
            j = j + 1
        end
    end
    local chisq, a = polynomialFit(3,t,"logarithmic")
    local c = { }
    c[1] = -a[2]/(2*a[3])                 -- x0
    c[2] = sqrt(a[3]<0 and (-ln2/a[3]) or (ln2/a[3])) -- hwhm
    c[3] = exp(a[1] - a[2]*a[2]/(4*a[3])) -- A
    c[4] = cst
    if coefs and csq then
        chisq = exp(sqrt(chisq))
        chisq = chisq * chisq
        mpprint("hide(")
            mpprint(csq..":="..tostring(chisq)..";")
            for i=1,#c do
                mpprint(coefs..tostring(i-1)..":="..tostring(c[i])..";")
            end
        mpprint(")")
    end
    for i=1,#t do
        local t_i = t[i]
        local x  = t_i[1]
        t_i[2] = GaussianFunction(c,x)
    end
    t.cycle = path.cycle
    mppath(t,"--")
end

-- Lorentzian: y = a2 / (1 + ((x - a0)/a1)^2)

local function LorentzianFunction(c,x)
             x = tonumber(x) or 0
    local x0   = tonumber(c[1]) or 0
    local hwhm = tonumber(c[2]) or 1
    local A    = tonumber(c[3]) or 1
    local cst  = tonumber(c[4]) or 0
    if hwhm == 0 then -- return a delta function
        if x == x0 then
            return A + cst
        end
        return cst
    end
    return A / (1 + ((x-x0)/hwhm)^2) + cst
end

function mp.LorentzianFit(name,coefs,csq,cst)
    cst = tonumber(cst) or 0

    local path = scanpath(name)
    local n = path and #path or 0
    local t = { }
    local j = 1
    for i=1,n do
        local p_i = path[i]
        local x = p_i[1]
        local y = p_i[2] - cst
        if y~=0 then -- skip points where ordinate is zero
            t[j] = { x, 1/y } -- inverse of the ordinate
            j = j + 1
        end
    end
    local chisq, a = polynomialFit(3,t) --,"inverse")
    local a1,a2,a3 = a[1],a[2],a[3]
    local c = { }
    local x0 = -a2/(2*a3)
    local A  =  1/(a1 - a2*a2/(4*a3))
    local h2 =  1/(a3*A)
    c[1] = x0
    c[2] = sqrt(h2 < 0 and -h2 or h2)
    c[3] = A
    c[4] = cst
inspect(a)
inspect(c)
    if coefs and csq then
        chisq = 1/chisq
        mpprint("hide(")
            mpprint(csq..":="..tostring(chisq)..";")
            for i=1,#c do
                mpprint(coefs..tostring(i-1)..":="..tostring(c[i])..";")
            end
        mpprint(")")
    end
    for i=1,#t do
        local t_i = t[i]
        local x  = t_i[1]
        t_i[2] = LorentzianFunction(c,x)
    end
    t.cycle = path.cycle
    mppath(t,"--")
end

-- data handling functions

local mycsvsplitter = utilities.parsers.rfc4180splitter()
local loaddata      = io.loaddata

-- userdata is not saved between runs anyways

userdata.list = { }
local list = userdata.list

local report = logs.reporter("table cache")

function mp.CSVDataLoad(filename)
    local lf = list[filename]
    if not lf then
        local basename = file.nameonly(filename)
        local tmafile  = basename .. ".tma"
        local tmcfile  = basename .. ".tmc"
        if not lfs.isfile(tmcfile) or file.needsupdating(filename,tmcfile) then
            local header
            report("loading %a",filename)
            statistics.starttiming()
            lf,header = mycsvsplitter(loaddata(filename),true)
            lf.header = header
            statistics.stoptiming()
            report("load time %s seconds",statistics.elapsedtime())
            report("saving %a",tmafile)
            statistics.starttiming()
          --table.save(tmafile,lf)
            io.savedata(tmafile,table.fastserialize(lf))
            statistics.stoptiming()
            report("save time %s seconds",statistics.elapsedtime())
            statistics.starttiming()
            utilities.lua.compile(tmafile,tmcfile)
            statistics.stoptiming()
            report("compiling time %s seconds",statistics.elapsedtime())
            file.syncmtimes(filename,tmafile)
            file.syncmtimes(filename,tmcfile)
        else
            report("loading %a",tmcfile)
            statistics.starttiming()
            lf = table.load(tmcfile) or table.load(tmafile)
            statistics.stoptiming()
            report("load time %s seconds",statistics.elapsedtime())
        end
        list[filename] = lf
    end
    mpprint(#lf)
end

local tonumber = tonumber

local function DataTableValue(t,c)
    c = tonumber(c) or c
    if t[c] then
        return t[c]
    end

    local a, b = match(c,"(%w+)%[(%w+)%]")
    if b then
        return t[a][tonumber(b) or b]
    end
    a = tonumber(a) or a
    if t[a] then
        return t[a]
    end
    return nil
end

function mp.CSVDataPath (filename,x,y,cycle,f,l)
    local t = { }
    local lf = list[filename]
    if lf then
        x = tonumber(x) or 1
        y = tonumber(y) or 2
        f = tonumber(f) or 1
        l = tonumber(l) or #lf
        if f<0 then f = #lf + f end
        if l<0 then l = #lf + l end
        f = (f<1 and 1) or (f>#lf and #lf) or f
        l = (l<1 and 1) or (l>#lf and #lf) or l
        local s = f>l and -1 or 1
        local n = 0
        for i=f,l,s do
            local lfi = lf[i]
            local xn, yn = x == 0 and i or tonumber(lfi[x]) or i,
                                           tonumber(DataTableValue(lfi,y) or
                                           i)
            if xn and yn then
                n = n + 1
                t[n] = { xn, yn }
            end
        end
    end
    if #t == 0 then t[1] = { 0,0 } end -- fallback: return origin 
    if cycle then
        t.cycle = true
        mppath(t,"--",true)
    else
        mppath(t,"--",false)
    end
end

function mp.CSVDataValue(filename,r,c)
    local lf  = list[filename]
    if not lf then
        mpprint(false)
    else
        r = tonumber(r) or r
        c = tonumber(c) or c
        if r==0 then
            local hf = lf.header
            if type(c)=="number" then
                if c<0 then c = #hf + c end
                c = (c<1 and 1) or (c>#hf and #hf) or c
            end
            local hfc = DataTableValue(hf,c)
            if type(hfc)=="number" then
                mpprint(hfc)
            else
                mpquoted(hfc)
            end
        else
            r = (r<0 and #lf + r) or r
          --r = (r<1 and 1) or (r>#lf and #lf) or r
            local lfr = lf[r]
            if type(c)=="number" then
                if c<0 then c = #lfr + c end
                c = (c<1 and 1) or (c>#lfr and #lfr) or c
            end
            local lfrc = DataTableValue(lfr,c)
            if type(lfrc)=="number" then
                mpprint(lfrc)
            else
                mpquoted(lfrc)
            end
        end
    end
end


-- extras

function mp.CSVDataAverageSD (filename,y,f,l)
    local lf = list[filename]
    y = tonumber(y) or y
    f = tonumber(f) or 1
    l = tonumber(l) or #lf
    if f<0 then f = #lf + f end
    if l<0 then l = #lf + l end
    f = (f<1 and 1) or (f>#lf and #lf) or f
    l = (l<1 and 1) or (l>#lf and #lf) or l
    local s = f>l and -1 or 1
    local n,sum,sumsq = 0,0,0
    for i=f,l,s do
        local lfi = lf[i]
        local v = tonumber(lfi[y])
        n = n + 1
        sum = sum + v
        sumsq = sumsq + v*v
    end
    local ave = sum/n
    mppair(ave,sqrt(sumsq/n-ave*ave))
end

function mp.CSVDataMinMax (filename,y,f,l)
    local lf = list[filename]
    y = tonumber(y) or y
    f = tonumber(f) or 1
    l = tonumber(l) or #lf
    if f<0 then f = #lf + f end
    if l<0 then l = #lf + l end
    f = (f<1 and 1) or (f>#lf and #lf) or f
    l = (l<1 and 1) or (l>#lf and #lf) or l
    local s = f>l and -1 or 1
    local n = 0
    local max, min
    for i=f,l,s do
        local lfi = lf[i]
        local v = tonumber(lfi[y])
        if i==f then
            max = v
            min = v
        else
            if v>max then max = v end
            if v<min then min = v end
        end
    end
    mppair(min,max)
end
